<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 空间无限延伸时间轴 - 霓虹多重宇宙版</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            /*改为深色背景以突出发光*/
            font-family: 'Helvetica Neue', Arial, sans-serif;
            cursor: grab;
        }

        body.grabbing {
            cursor: grabbing;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            /* 文字改为白色 */
            pointer-events: none;
            z-index: 10;
            mix-blend-mode: difference;
        }

        h1 {
            font-weight: 300;
            letter-spacing: 2px;
            margin: 0;
            text-transform: uppercase;
            font-size: 1.2rem;
            border-bottom: 1px solid #00ffff;
            /* 标题下划线改为青色 */
            display: inline-block;
            padding-bottom: 5px;
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        p {
            font-size: 0.8rem;
            opacity: 0.8;
            margin-top: 5px;
            color: #ccc;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-size: 1.5rem;
            letter-spacing: 5px;
            transition: opacity 0.5s;
            text-shadow: 0 0 15px #00ffff;
        }
    </style>
</head>

<body>

    <div id="ui">
        <h1>NEON INFINITY // MULTIVERSE</h1>
        <p>5 PARALLEL TIMELINES • NEON GLOW ACTIVE<br>5条并行主线 • 自发光边框 • 滚轮拉远查看全貌</p>
    </div>

    <div id="loading" class="loading">SYSTEM INITIALIZING...</div>
    <div id="canvas-container"></div>

    <!-- Three.js Core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- Post-Processing Dependencies (来自 GitHub CDN) -->
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/shaders/CopyShader.js"></script>
    <script
        src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script
        src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/postprocessing/ShaderPass.js"></script>
    <script
        src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <script>
        // --- 配置参数 ---
        const config = {
            // 环境颜色调整为深色
            bgColor: 0x050505,
            fogColor: 0x050505,
            heightFogDensity: 0.005,
            heightFogBase: -50.0,

            // 材质颜色
            blockColor: 0x111111,    // 块体改为深灰，作为发光线条的背景
            lineColor: 0x222222,     // 普通连接线颜色

            // 发光配置
            mainEdgeColor: 0x00ffff, // 主线发光边框颜色 (青色)
            dimEdgeColor: 0x333333,  // 装饰性建筑的边框颜色 (不发光)

            textColor: '#ffffff',    // 贴图文字颜色
            spacingZ: 40,

            renderRange: 45,

            laneCount: 5,
            laneDist: 350,
            crossLinkChance: 0.15
        };

        // --- 核心变量 ---
        let scene, camera, renderer, composer; // 增加 composer
        let scrollPos = -50;
        let targetScrollPos = -50;

        let activeIndices = new Set();

        let cameraHeight = 100;
        let targetCameraHeight = 100;

        let isDragging = false;
        let previousMouseY = 0;

        let objects = [];

        // 材质区分
        let boxMat, lineMat, dimEdgesMat, glowEdgesMat, personMat;
        let heightFogShaderLogic;

        // --- 初始化 ---
        function init() {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(config.bgColor);

            scene.fog = new THREE.FogExp2(config.fogColor, 0.0006);

            // Shader 注入逻辑 (保持雾效)
            heightFogShaderLogic = (shader) => {
                shader.uniforms.hFogColor = { value: new THREE.Color(config.fogColor) };
                shader.uniforms.hFogDensity = { value: config.heightFogDensity };
                shader.uniforms.hFogBase = { value: config.heightFogBase };

                shader.vertexShader = shader.vertexShader.replace(
                    `#include <common>`,
                    `#include <common>
                    varying vec3 vWorldPosition;`
                );
                shader.vertexShader = shader.vertexShader.replace(
                    `#include <begin_vertex>`,
                    `#include <begin_vertex>
                    vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;`
                );

                shader.fragmentShader = shader.fragmentShader.replace(
                    `#include <common>`,
                    `#include <common>
                    uniform vec3 hFogColor;
                    uniform float hFogDensity;
                    uniform float hFogBase;
                    varying vec3 vWorldPosition;`
                );

                shader.fragmentShader = shader.fragmentShader.replace(
                    `#include <fog_fragment>`,
                    `
                    float heightFactor = 0.0;
                    if (vWorldPosition.y < hFogBase) {
                        float dist = hFogBase - vWorldPosition.y;
                        heightFactor = 1.0 - exp(-dist * hFogDensity);
                    }
                    heightFactor = clamp(heightFactor, 0.0, 1.0);
                    gl_FragColor.rgb = mix(gl_FragColor.rgb, hFogColor, heightFactor);
                    #include <fog_fragment>
                    `
                );
            };

            // 实体材质 (深色)
            boxMat = new THREE.MeshLambertMaterial({ color: config.blockColor });
            boxMat.onBeforeCompile = heightFogShaderLogic;

            // 连接线材质
            lineMat = new THREE.LineBasicMaterial({ color: config.lineColor, transparent: true, opacity: 0.3 });
            lineMat.onBeforeCompile = heightFogShaderLogic;

            // 【关键】不发光的暗淡边框 (用于背景建筑)
            dimEdgesMat = new THREE.LineBasicMaterial({ color: config.dimEdgeColor, transparent: true, opacity: 0.4 });
            dimEdgesMat.onBeforeCompile = heightFogShaderLogic;

            // 【关键】发光的主线边框 (高亮青色)
            glowEdgesMat = new THREE.LineBasicMaterial({ color: config.mainEdgeColor, linewidth: 2 });
            // 注意：LineBasicMaterial 不受光照影响，它的颜色就是最终颜色，配合 BloomPass 即可发光
            glowEdgesMat.onBeforeCompile = heightFogShaderLogic;

            personMat = new THREE.MeshBasicMaterial({ color: 0x00aaaa }); // 小人也稍微改亮一点

            camera = new THREE.PerspectiveCamera(25, window.innerWidth / window.innerHeight, 10, 10000);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            // 开启物理正确的灯光计算通常有助于 Bloom 效果，但在这种抽象风格中可选
            // renderer.toneMapping = THREE.ReinhardToneMapping; 
            container.appendChild(renderer.domElement);

            // --- Post-Processing: Bloom (泛光) ---
            const renderScene = new THREE.RenderPass(scene, camera);

            // 参数: resolution, strength, radius, threshold
            // strength: 泛光强度 (1.5 很强)
            // radius: 泛光扩散半径 (0.4 适中)
            // threshold: 亮度阈值 (0: 所有东西都发光, 1: 只有极亮的发光)
            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0; // 设置为0让线条更容易发光，因为我们通过颜色控制
            bloomPass.strength = 1.8; // 增强发光强度
            bloomPass.radius = 0.5;

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
            // -------------------------------------

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // 降低环境光，增加对比度
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(100, 200, 100);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 4096;
            dirLight.shadow.mapSize.height = 4096;
            const shadowRange = config.laneCount * config.laneDist + 500;
            dirLight.shadow.camera.left = -500;
            dirLight.shadow.camera.right = shadowRange;
            dirLight.shadow.camera.top = 500;
            dirLight.shadow.camera.bottom = -500;
            dirLight.shadow.camera.near = 0.1;
            dirLight.shadow.camera.far = 2000;
            // 稍微偏蓝的灯光
            dirLight.color.setHSL(0.6, 0.2, 1.0);
            scene.add(dirLight);

            // 地面网格改为极暗
            const gridHelper = new THREE.GridHelper(20000, 1000, 0x111111, 0x0a0a0a);
            gridHelper.position.y = -20;
            if (gridHelper.material instanceof THREE.Material) {
                gridHelper.material.onBeforeCompile = heightFogShaderLogic;
                gridHelper.material.transparent = true;
                gridHelper.material.opacity = 0.2;
            }
            scene.add(gridHelper);

            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('wheel', onDocumentMouseWheel, { passive: false });
            document.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('mouseup', onMouseUp, false);
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('mouseleave', onMouseUp, false);

            document.getElementById('loading').style.opacity = 0;

            animate();
        }

        // --- 数据生成逻辑 ---
        function generateDataForIndex(i, laneIdx) {
            const year = 2024 - i;
            const prefixes = ["INIT", "CORE", "NODE", "DATA", "SYNC"];
            const descs = [
                "Analysis complete.",
                "Foundation sector.",
                "Integration core.",
                "System upgrade.",
                "Link established."
            ];
            const laneNames = ["ALPHA", "BETA", "GAMMA", "DELTA", "EPSILON", "ZETA", "ETA", "THETA"];
            const laneName = laneNames[laneIdx % laneNames.length];
            const safeIdx = Math.abs(i);
            return {
                year: year.toString(),
                title: `${prefixes[safeIdx % prefixes.length]} ${laneName}-${safeIdx + 1}`,
                desc: descs[safeIdx % descs.length]
            };
        }

        function createRow(index) {
            const laneGroups = [];
            for (let l = 0; l < config.laneCount; l++) {
                const group = createLane(index, l);
                laneGroups.push(group);
            }

            // 跨线连接
            for (let l = 0; l < config.laneCount - 1; l++) {
                const linkSeed = Math.sin(index * 999 + l * 777) * 43758.5453;
                const shouldLink = ((linkSeed - Math.floor(linkSeed)) < config.crossLinkChance);

                if (shouldLink) {
                    const groupA = laneGroups[l];
                    const groupB = laneGroups[l + 1];
                    const posA = groupA.position;
                    const posB = groupB.position;

                    const startLocal = new THREE.Vector3(0, 0, 0);
                    const endLocal = new THREE.Vector3(
                        posB.x - posA.x,
                        posB.y - posA.y,
                        posB.z - posA.z
                    );

                    const linkGeo = new THREE.BufferGeometry().setFromPoints([startLocal, endLocal]);
                    // 跨线连接使用普通线材质，不发光
                    const linkLine = new THREE.Line(linkGeo, lineMat);
                    groupA.add(linkLine);

                    const midPoint = endLocal.clone().multiplyScalar(0.5);
                    const markerGeo = new THREE.BoxGeometry(2, 2, 2);
                    const marker = new THREE.Mesh(markerGeo, boxMat);
                    marker.position.copy(midPoint);
                    groupA.add(marker);
                }
            }
        }

        function createLane(index, laneIdx) {
            const boxGeo = new THREE.BoxGeometry(1, 1, 1);
            const personGeo = new THREE.ConeGeometry(0.15, 0.8, 8);
            const data = generateDataForIndex(index, laneIdx);

            const seedBase = index * 12.9898 + (laneIdx * 999.99);
            const seed = Math.sin(seedBase) * 43758.5453;
            const pseudoRand = (offset) => (Math.sin(seed + offset) * 10000) % 1;

            const zPos = -index * config.spacingZ;
            const laneOffsetX = laneIdx * config.laneDist;

            // --- 1. 主体时间线 (Main Timeline) ---
            const group = new THREE.Group();
            const xPos = laneOffsetX + pseudoRand(1) * 20;
            const yPos = pseudoRand(2) * 10;

            group.position.set(xPos, yPos, zPos);
            group.userData = { baseY: yPos, type: 'main', index: index, lane: laneIdx };
            group.scale.set(0, 0, 0);

            // 纵向连接线
            const nextIndex = index + 1;
            const nextSeedBase = nextIndex * 12.9898 + (laneIdx * 999.99);
            const nextSeed = Math.sin(nextSeedBase) * 43758.5453;
            const nextPseudoRand = (offset) => (Math.sin(nextSeed + offset) * 10000) % 1;

            const nextXPos = laneOffsetX + nextPseudoRand(1) * 20;
            const nextYPos = nextPseudoRand(2) * 10;
            const nextZPos = -nextIndex * config.spacingZ;

            const lineEndLocal = new THREE.Vector3(
                nextXPos - xPos,
                nextYPos - yPos,
                nextZPos - zPos
            );

            const timelineConnGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                lineEndLocal
            ]);
            const timelineConnLine = new THREE.Line(timelineConnGeo, lineMat);
            group.add(timelineConnLine);

            // 主平台
            const mainSx = 4 + Math.abs(pseudoRand(3)) * 4;
            const mainSy = 1 + Math.abs(pseudoRand(4)) * 2;
            const mainSz = 4 + Math.abs(pseudoRand(5)) * 4;

            const platform = new THREE.Mesh(boxGeo, boxMat);
            platform.scale.set(mainSx, mainSy, mainSz);
            platform.castShadow = true;
            platform.receiveShadow = true;

            // 【关键】主平台使用发光材质 (glowEdgesMat)
            const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(mainSx, mainSy, mainSz));
            const edgeLines = new THREE.LineSegments(edges, glowEdgesMat);
            platform.add(edgeLines);
            group.add(platform);

            // 水平分支 (使用暗淡线条)
            if (Math.abs(pseudoRand(10)) > 0.6) {
                const branchDir = pseudoRand(11) > 0 ? 1 : -1;
                const segments = 2 + Math.floor(Math.abs(pseudoRand(12)) * 3);

                let currentBranchX = (mainSx / 2) * branchDir;
                let currentBranchY = 0;
                let currentBranchZ = 0;

                for (let s = 0; s < segments; s++) {
                    const distX = (25 + Math.abs(pseudoRand(20 + s)) * 35) * branchDir;
                    const distY = (pseudoRand(14 + s) - 0.5) * 30;
                    const distZ = (pseudoRand(19 + s) - 0.5) * 30;

                    const nextX = currentBranchX + distX;
                    const nextY = currentBranchY + distY;
                    const nextZ = currentBranchZ + distZ;

                    const connGeo = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(currentBranchX, currentBranchY, currentBranchZ),
                        new THREE.Vector3(nextX, nextY, nextZ)
                    ]);
                    const connLine = new THREE.Line(connGeo, lineMat);
                    group.add(connLine);

                    const bSx = 3 + Math.abs(pseudoRand(15 + s)) * 30;
                    const bSy = 1 + Math.abs(pseudoRand(16 + s));
                    const bSz = 3 + Math.abs(pseudoRand(17 + s)) * 30;

                    // 分支平台使用暗淡边框
                    const bEdges = new THREE.EdgesGeometry(new THREE.BoxGeometry(bSx, bSy, bSz));
                    const bEdgeLines = new THREE.LineSegments(bEdges, dimEdgesMat);
                    bEdgeLines.position.set(nextX, nextY, nextZ);
                    group.add(bEdgeLines);

                    const bLineHeight = 8 + Math.abs(pseudoRand(18 + s)) * 8;
                    const bVertLine = new THREE.Line(
                        new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(nextX, nextY, nextZ),
                            new THREE.Vector3(nextX, nextY + bLineHeight, nextZ)
                        ]),
                        lineMat
                    );
                    group.add(bVertLine);

                    const bPanelGeo = new THREE.PlaneGeometry(6, 6);
                    const bPanelText = createTextTexture(data.year, "NODE " + s, "Sub-branch");
                    const bPanelMat = new THREE.MeshBasicMaterial({
                        map: bPanelText,
                        side: THREE.DoubleSide,
                        transparent: true,
                        blending: THREE.AdditiveBlending // 增加文字的发光感
                    });
                    bPanelMat.onBeforeCompile = heightFogShaderLogic;

                    const bPanel = new THREE.Mesh(bPanelGeo, bPanelMat);
                    bPanel.position.set(nextX + 4, nextY + bLineHeight, nextZ);
                    bPanel.rotation.y = -Math.PI / 4;
                    group.add(bPanel);

                    currentBranchX = nextX;
                    currentBranchY = nextY;
                    currentBranchZ = nextZ;
                }
            }

            // 信息面板连接线 (主线)
            const lineHeight = 10 + Math.abs(pseudoRand(6)) * 10;
            const lineGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, lineHeight, 0)
            ]);
            // 使用发光材质使连接线也发光，增加科技感
            const line = new THREE.Line(lineGeo, glowEdgesMat);
            line.position.set(mainSx / 2 - 0.5, mainSy / 2, mainSz / 2 - 0.5);
            group.add(line);

            const panelWidth = 8;
            const panelHeight = 8;
            const panelGeo = new THREE.PlaneGeometry(panelWidth, panelHeight);
            const panelTexture = createTextTexture(data.year, data.title, data.desc);
            const panelMat = new THREE.MeshBasicMaterial({
                map: panelTexture,
                side: THREE.DoubleSide,
                transparent: true,
                depthWrite: false, // 防止透明遮挡
                blending: THREE.AdditiveBlending // 叠加混合模式让文字更亮
            });
            panelMat.onBeforeCompile = heightFogShaderLogic;

            const panel = new THREE.Mesh(panelGeo, panelMat);
            panel.position.set(mainSx / 2 - 0.5 + panelWidth / 2, mainSy / 2 + lineHeight, mainSz / 2 - 0.5);
            panel.rotation.y = -Math.PI / 4;
            group.add(panel);

            const person = new THREE.Mesh(personGeo, personMat);
            person.position.set(0, mainSy / 2 + 0.4, 0);
            group.add(person);

            scene.add(group);
            objects.push(group);

            // --- 2. 密集底部建筑群 (Background) ---
            // 使用暗淡材质
            const bottomCount = 2 + Math.floor(Math.abs(pseudoRand(7)) * 4);
            for (let k = 0; k < bottomCount; k++) {
                const bGroup = new THREE.Group();
                const zOffset = pseudoRand(k * 10) * 120;
                const bZPos = zPos + zOffset;

                const placeType = Math.floor(Math.abs(pseudoRand(k * 123)) * 3);
                let bXOffset = 0;
                const halfDist = config.laneDist / 2;

                if (placeType === 0) {
                    bXOffset = pseudoRand(k * 20) * 80;
                    if (Math.abs(bXOffset) < 25) bXOffset += (bXOffset > 0 ? 25 : -25);
                } else if (placeType === 1) {
                    bXOffset = halfDist + pseudoRand(k * 30) * 100;
                } else {
                    bXOffset = -halfDist + pseudoRand(k * 40) * 100;
                }

                const bXPos = laneOffsetX + bXOffset;
                const bYBase = -100 - Math.abs(pseudoRand(k * 30)) * 250;

                bGroup.position.set(bXPos, bYBase, bZPos);
                bGroup.userData = { baseY: bYBase, type: 'bottom', index: index, lane: laneIdx };
                bGroup.scale.set(0, 0, 0);

                const floors = 1 + Math.floor(Math.abs(pseudoRand(k * 40)) * 6);
                let currentY = 0;
                const baseW = 15 + Math.abs(pseudoRand(k * 50)) * 25;
                const baseD = 15 + Math.abs(pseudoRand(k * 60)) * 25;

                for (let f = 0; f < floors; f++) {
                    const h = 20 + Math.abs(pseudoRand(k * 70 + f)) * 30;
                    const taper = 1.0 - (f * 0.08);
                    const w = baseW * taper;
                    const d = baseD * taper;

                    const bMesh = new THREE.Mesh(boxGeo, boxMat);
                    bMesh.scale.set(w, h, d);
                    bMesh.position.set(0, currentY + h / 2, 0);
                    bMesh.castShadow = true;
                    bMesh.receiveShadow = true;
                    bGroup.add(bMesh);

                    const bEdges = new THREE.EdgesGeometry(new THREE.BoxGeometry(w, h, d));
                    // 背景建筑使用暗淡边框
                    const bLines = new THREE.LineSegments(bEdges, dimEdgesMat);
                    bLines.position.set(0, currentY + h / 2, 0);
                    bGroup.add(bLines);
                    currentY += h;
                }

                const antennaH = 50 + Math.abs(pseudoRand(k * 80)) * 150;
                const antenna = new THREE.Line(
                    new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(0, currentY, 0),
                        new THREE.Vector3(0, currentY + antennaH, 0)
                    ]),
                    lineMat
                );
                bGroup.add(antenna);

                scene.add(bGroup);
                objects.push(bGroup);
            }

            // --- 3. 倒置天空建筑群 (Background) ---
            const topCount = 1 + Math.floor(Math.abs(pseudoRand(100)) * 2);
            for (let k = 0; k < topCount; k++) {
                const tGroup = new THREE.Group();
                const zOffset = pseudoRand(k * 15) * 120;
                const tZPos = zPos + zOffset;

                let randOffset = pseudoRand(k * 25) * 240;
                if (Math.abs(randOffset) < 30) randOffset += (randOffset > 0 ? 30 : -30);
                const tXPos = laneOffsetX + randOffset;

                const tYBase = 350 + Math.abs(pseudoRand(k * 35)) * 150;

                tGroup.position.set(tXPos, tYBase, tZPos);
                tGroup.userData = { baseY: tYBase, type: 'top', index: index, lane: laneIdx };
                tGroup.scale.set(0, 0, 0);

                const floors = 2 + Math.floor(Math.abs(pseudoRand(k * 45)) * 4);
                let currentY = 0;
                const baseW = 15 + Math.abs(pseudoRand(k * 55)) * 25;
                const baseD = 15 + Math.abs(pseudoRand(k * 65)) * 25;

                for (let f = 0; f < floors; f++) {
                    const h = 20 + Math.abs(pseudoRand(k * 75 + f)) * 40;
                    const taper = 1.0 - (f * 0.05);
                    const w = baseW * taper;
                    const d = baseD * taper;

                    const tMesh = new THREE.Mesh(boxGeo, boxMat);
                    tMesh.scale.set(w, h, d);
                    tMesh.position.set(0, currentY - h / 2, 0);
                    tMesh.castShadow = true;
                    tMesh.receiveShadow = true;
                    tGroup.add(tMesh);

                    const tEdges = new THREE.EdgesGeometry(new THREE.BoxGeometry(w, h, d));
                    // 天空建筑使用暗淡边框
                    const tLines = new THREE.LineSegments(tEdges, dimEdgesMat);
                    tLines.position.set(0, currentY - h / 2, 0);
                    tGroup.add(tLines);

                    currentY -= h;
                }

                const antennaH = 50 + Math.abs(pseudoRand(k * 95)) * 150;
                const antenna = new THREE.Line(
                    new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(0, currentY, 0),
                        new THREE.Vector3(0, currentY - antennaH, 0)
                    ]),
                    lineMat
                );
                tGroup.add(antenna);

                scene.add(tGroup);
                objects.push(tGroup);
            }

            return group;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (composer) composer.setSize(window.innerWidth, window.innerHeight);
        }

        function onDocumentMouseWheel(event) {
            event.preventDefault();
            targetCameraHeight += event.deltaY * 0.5;
            if (targetCameraHeight < 10) targetCameraHeight = 10;
            if (targetCameraHeight > 3000) targetCameraHeight = 3000;
        }

        function onMouseDown(event) {
            isDragging = true;
            previousMouseY = event.clientY;
            document.body.classList.add('grabbing');
        }

        function onMouseUp() {
            isDragging = false;
            document.body.classList.remove('grabbing');
        }

        function onMouseMove(event) {
            if (!isDragging) return;
            const deltaY = event.clientY - previousMouseY;
            previousMouseY = event.clientY;
            targetScrollPos += deltaY * 0.5;
        }

        // --- 纹理生成 (反色处理以适应深色背景) ---
        function createTextTexture(year, title, desc) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const width = 512;
            const height = 512;
            canvas.width = width;
            canvas.height = height;

            // 背景半透明黑
            ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
            ctx.fillRect(0, 0, width, height);

            // 边框青色
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 6;
            ctx.strokeRect(0, 0, width, height);

            ctx.fillStyle = config.textColor;
            ctx.textAlign = 'left';

            ctx.font = 'bold 120px Helvetica, Arial';
            ctx.shadowColor = "#00ffff";
            ctx.shadowBlur = 10;
            ctx.fillText(year, 40, 140);
            ctx.shadowBlur = 0; // 重置

            ctx.beginPath();
            ctx.moveTo(40, 160);
            ctx.lineTo(width - 40, 160);
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#00ffff';
            ctx.stroke();

            ctx.font = 'bold 40px Helvetica, Arial';
            ctx.fillText(title, 40, 220);

            ctx.font = 'normal 28px Helvetica, Arial';
            const words = desc.split(' ');
            let line = '';
            let y = 280;
            for (let n = 0; n < words.length; n++) {
                const testLine = line + words[n] + ' ';
                const metrics = ctx.measureText(testLine);
                if (metrics.width > width - 80 && n > 0) {
                    ctx.fillText(line, 40, y);
                    line = words[n] + ' ';
                    y += 40;
                } else {
                    line = testLine;
                }
            }
            ctx.fillText(line, 40, y);

            // 装饰点
            ctx.fillStyle = '#00ffff';
            ctx.fillRect(40, height - 40, 20, 20);
            ctx.fillRect(70, height - 40, 20, 20);

            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            return texture;
        }

        // --- 动画循环 ---
        function animate() {
            requestAnimationFrame(animate);

            scrollPos += (targetScrollPos - scrollPos) * 0.05;
            cameraHeight += (targetCameraHeight - cameraHeight) * 0.05;

            const currentIndex = Math.floor(scrollPos / config.spacingZ);
            const minIdx = currentIndex - config.renderRange;
            const maxIdx = currentIndex + config.renderRange;

            for (let i = minIdx; i <= maxIdx; i++) {
                if (!activeIndices.has(i)) {
                    createRow(i);
                    activeIndices.add(i);
                }
            }

            const baseHeight = 100;
            const baseRelX = -100;
            const baseRelZ = 120;
            const scale = cameraHeight / baseHeight;

            const currentDistX = baseRelX * scale;
            const currentDistZ = baseRelZ * scale;

            const centerLaneIndex = Math.floor(config.laneCount / 2);
            const centerLineX = centerLaneIndex * config.laneDist;

            const targetX = centerLineX;
            const targetY = 0;
            const currentFocusZ = -scrollPos;

            const camX = targetX + currentDistX;
            const camY = cameraHeight;
            const camZ = currentFocusZ + currentDistZ;

            camera.position.set(camX, camY, camZ);
            camera.lookAt(targetX, targetY, currentFocusZ);

            const light = scene.getObjectByName("mainLight");
            if (light) {
                light.position.set(camX + 50, camY + 50, camZ + 50);
                light.target.position.set(targetX, targetY, currentFocusZ);
                light.target.updateMatrixWorld();
            }

            for (let i = objects.length - 1; i >= 0; i--) {
                const obj = objects[i];
                const objIndex = obj.userData.index;

                if (objIndex < minIdx || objIndex > maxIdx) {
                    scene.remove(obj);
                    obj.traverse((child) => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (child.material.map) child.material.map.dispose();
                            child.material.dispose();
                        }
                    });
                    objects.splice(i, 1);
                    activeIndices.delete(objIndex);
                    continue;
                }

                const dist = obj.position.z - currentFocusZ;
                const isVisible = dist > -650 && dist < 300;
                const targetScale = isVisible ? 1 : 0;

                let hiddenOffset = -50;
                if (obj.userData.type === 'top') hiddenOffset = 50;

                const targetY = isVisible ? obj.userData.baseY : (obj.userData.baseY + hiddenOffset);

                const lerpSpeed = 0.05;
                if (Math.abs(obj.scale.x - targetScale) > 0.001 || Math.abs(obj.position.y - targetY) > 0.01) {
                    obj.scale.setScalar(THREE.MathUtils.lerp(obj.scale.x, targetScale, lerpSpeed));
                    obj.position.y = THREE.MathUtils.lerp(obj.position.y, targetY, lerpSpeed);
                } else {
                    obj.scale.setScalar(targetScale);
                    obj.position.y = targetY;
                }

                const time = Date.now() * 0.001;
                if (targetScale === 1 && obj.scale.x > 0.9) {
                    obj.children.forEach(c => {
                        if (c.geometry.type === 'PlaneGeometry') {
                            c.position.y += Math.sin(time + i + (obj.userData.lane || 0)) * 0.005;
                        }
                    });
                }
            }

            // 使用 composer 代替 renderer
            if (composer) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
        }

        init();

    </script>
</body>

</html>