<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEURO-DETECTIVE: RIVALRY UPDATE</title>

    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.9/dist/vis-network.min.js"></script>

    <style>
        :root {
            --bg-color: #050a10;
            --panel-bg: #0f1623;
            --border-color: #233142;
            --accent-color: #00ffcc;
            --narrative-color: #ffcc00;
            --loc-color: #4a9eff;
            --item-color: #d2a8ff;
            --danger-color: #ff3366; /* Boss 色 */
            --text-color: #d0d7de;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', 'Roboto Mono', monospace;
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        /* 顶部 HUD */
        #hud-bar {
            background: rgba(15, 22, 35, 0.95);
            padding: 10px 20px;
            border-bottom: 2px solid var(--accent-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
            height: 40px;
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.2);
        }

        .mission-info {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .stage-indicator {
            color: var(--narrative-color);
            font-weight: bold;
            border: 1px solid var(--narrative-color);
            padding: 2px 8px;
            font-size: 0.8rem;
        }

        /* 主布局 */
        #main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        /* 左侧：图谱 */
        #graphs-column {
            flex: 2;
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border-color);
            background: #000;
        }

        .graph-section {
            flex: 1;
            position: relative;
            border-bottom: 1px solid var(--border-color);
            overflow: hidden;
        }
        .graph-section:last-child { border-bottom: none; }

        .graph-label {
            position: absolute;
            top: 5px; left: 5px;
            font-size: 0.75rem;
            padding: 2px 8px;
            background: rgba(0,0,0,0.7);
            border-left: 3px solid;
            z-index: 10;
            pointer-events: none;
        }

        #viz-location { width: 100%; height: 100%; background: radial-gradient(circle at center, #0f1c2e 0%, #000 100%); }
        #viz-inventory { width: 100%; height: 100%; background: radial-gradient(circle at center, #1a0f2e 0%, #000 100%); }
        #viz-narrative { width: 100%; height: 100%; background: radial-gradient(circle at center, #2e260f 0%, #000 100%); }

        /* 右侧交互终端 */
        #terminal-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--panel-bg);
            max-width: 450px;
            border-left: 1px solid var(--border-color);
        }

        /* 新增：目标情报面板 */
        #intel-panel {
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-bottom: 1px solid var(--border-color);
            max-height: 150px;
            overflow-y: auto;
        }

        .intel-header {
            font-size: 0.8rem;
            color: #888;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
        }

        .keypoint-list {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .keypoint-item {
            font-size: 0.85rem;
            padding: 4px 8px;
            border: 1px solid #333;
            background: rgba(255,255,255,0.05);
            display: flex;
            justify-content: space-between;
        }

        .keypoint-item.player-owned { border-color: var(--accent-color); color: var(--accent-color); box-shadow: inset 3px 0 0 var(--accent-color); }
        .keypoint-item.boss-owned { border-color: var(--danger-color); color: var(--danger-color); box-shadow: inset 3px 0 0 var(--danger-color); text-decoration: line-through;}
        .keypoint-item.unknown { border-style: dashed; color: #666; }

        /* 聊天区 */
        #chat-history {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            scroll-behavior: smooth;
        }

        .msg { padding: 10px; border-radius: 4px; font-size: 0.9rem; line-height: 1.5; max-width: 95%; word-wrap: break-word;}
        .msg.ai { background: rgba(0, 255, 204, 0.05); border-left: 2px solid var(--accent-color); color: #fff; }
        .msg.boss { background: rgba(255, 51, 102, 0.05); border-left: 2px solid var(--danger-color); color: #ffcccc; font-style: italic; }
        .msg.user { background: rgba(255, 255, 255, 0.05); border-right: 2px solid #666; align-self: flex-end; text-align: right; }
        .msg.system { color: #666; font-size: 0.8rem; text-align: center; }
        .msg.stage-clear { border: 1px solid var(--narrative-color); color: var(--narrative-color); text-align: center; font-weight: bold; background: rgba(255, 204, 0, 0.1); padding: 15px; }

        /* 输入区 */
        #input-area {
            padding: 15px;
            border-top: 1px solid var(--border-color);
            display: flex;
            gap: 10px;
            background: rgba(0,0,0,0.3);
        }

        input[type="text"] {
            flex: 1; background: rgba(0,0,0,0.5); border: 1px solid #333; color: var(--accent-color); padding: 10px; font-family: 'Roboto Mono', monospace;
        }
        input[type="text"]:focus { outline: none; border-color: var(--accent-color); }
        button {
            background: rgba(0, 255, 204, 0.1); color: var(--accent-color); border: 1px solid var(--accent-color); cursor: pointer; font-family: 'Roboto Mono', monospace;
        }
        button:hover { background: var(--accent-color); color: #000; }
        button:disabled { border-color: #444; color: #444; cursor: not-allowed; background: transparent;}

        .scanline {
            width: 100%; height: 2px; background: var(--accent-color);
            position: absolute; top: 0; left: 0; opacity: 0; z-index: 50; pointer-events: none;
        }
        .scanning .scanline { opacity: 1; animation: scan 1.5s infinite linear; }
        @keyframes scan { 0% { top: 0%; } 100% { top: 100%; } }

    </style>
</head>
<body>

<div class="scanline" id="scan-effect"></div>

<div id="hud-bar">
    <div style="font-weight:900; letter-spacing:2px;">TRINITY<span style="color:var(--accent-color)">://</span>RIVAL</div>
    <div class="mission-info">
        <div id="stage-display" class="stage-indicator">STAGE 1</div>
        <div class="mission-objective" id="objective-display">目标: 获取关键数据</div>
    </div>
    <div><button id="reset-btn" onclick="startGame()" style="font-size:0.7rem; padding:5px;">REBOOT</button></div>
</div>

<div id="main-container">
    <div id="graphs-column">
        <div class="graph-section">
            <div class="graph-label" style="border-color: var(--loc-color); color: var(--loc-color);">LOCATION (RED=BOSS)</div>
            <div id="viz-location"></div>
        </div>
        <div class="graph-section">
            <div class="graph-label" style="border-color: var(--item-color); color: var(--item-color);">INVENTORY LINK</div>
            <div id="viz-inventory"></div>
        </div>
        <div class="graph-section">
            <div class="graph-label" style="border-color: var(--narrative-color); color: var(--narrative-color);">NARRATIVE PATH</div>
            <div id="viz-narrative"></div>
        </div>
    </div>

    <div id="terminal-panel">
        <div id="intel-panel">
            <div class="intel-header">
                <span>TARGET KEYPOINTS</span>
                <span style="font-size:0.7rem">RIVAL AGENT: ACTIVE</span>
            </div>
            <div id="keypoint-list-container" class="keypoint-list">
            </div>
        </div>

        <div id="chat-history">
            <div class="msg system">>> SYSTEM ONLINE. 竞争协议已启动...</div>
        </div>

        <div id="input-area">
            <input type="text" id="player-input" placeholder="输入指令 (e.g. 调查终端, 攻击BOSS...)" autocomplete="off" disabled>
            <button id="send-btn" onclick="handleInput()" disabled>SEND</button>
        </div>
    </div>
</div>

<script>
    // ==========================================
    // 1. 配置 & 状态管理
    // ==========================================
    const API_CONFIG = {
        url: "https://api.mindcraft.com.cn/v1/chat/completions",
        key: "MC-E5B8AB237AAC4EDCBFA26531D6BE0081",
        model: "gemini-3-pro-preview"
    };

    // 数据结构：由三个独立的图组成
    const GRAPH_STORE = {
        location: { nodes: null, edges: null, network: null },
        inventory: { nodes: null, edges: null, network: null },
        narrative: { nodes: null, edges: null, network: null }
    };

    // 游戏全局状态
    let gameState = {
        currentStage: 1,
        maxStages: 2,
        currentLocationId: 'loc_start',
        bossLocationId: 'loc_unknown',
        isGameOver: false,
        keypoints: [] // [{id: 'k1', name: 'Key', status: 'hidden' | 'player' | 'boss', desc: '...'}]
    };

    // 关卡配置
    const STAGE_CONFIG = {
        1: {
            name: "贫民窟的数据泄露",
            required_count: 2, // 需要2个才能过关
            keypoints: [
                { id: "kp_chip", name: "加密芯片", desc: "藏在废弃诊所的保险箱里", status: "hidden" },
                { id: "kp_id_card", name: "门禁卡", desc: "一名死去帮派成员的口袋里", status: "hidden" },
                { id: "kp_evidence", name: "录音笔", desc: "酒吧老板的私藏", status: "hidden" }
            ],
            boss_start: "loc_slums_entrance"
        },
        2: {
            name: "公司广场的对决",
            required_count: 2,
            keypoints: [
                { id: "kp_server_access", name: "服务器权限", desc: "主控室终端", status: "hidden" },
                { id: "kp_biometric", name: "生物样本", desc: "实验室冷库", status: "hidden" },
                { id: "kp_prototype", name: "原型武器", desc: "军火库展示台", status: "hidden" }
            ],
            boss_start: "loc_lobby"
        }
    };

    let conversationHistory = [];

    // ==========================================
    // 2. Vis.js 初始化
    // ==========================================

    function initOneGraph(containerId, optionsOverride = {}) {
        const nodes = new vis.DataSet([]);
        const edges = new vis.DataSet([]);
        const container = document.getElementById(containerId);

        const defaultOptions = {
            nodes: {
                shape: 'dot', size: 15,
                font: { color: '#fff', size: 12, face: 'Roboto Mono' },
                borderWidth: 2, shadow: true
            },
            edges: {
                width: 1, color: { color: '#555', highlight: '#fff' },
                smooth: { type: 'dynamic' }
            },
            physics: {
                stabilization: false,
                barnesHut: { gravitationalConstant: -2000, springConstant: 0.04 }
            },
            interaction: { hover: true, zoomView: true }
        };

        const options = { ...defaultOptions, ...optionsOverride };
        if(optionsOverride.edges) options.edges = { ...defaultOptions.edges, ...optionsOverride.edges };

        const network = new vis.Network(container, { nodes, edges }, options);
        return { nodes, edges, network };
    }

    function initAllGraphs() {
        // 1. Location Map:
        // 错误修复: arrows 不能写字符串 "to, from"，必须写成对象格式 { to: true, from: true }
        GRAPH_STORE.location = initOneGraph('viz-location', {
            edges: {
                arrows: { to: { enabled: true }, from: { enabled: true } },
                color: '#4a9eff'
            }
        });

        // 2. Inventory:
        // 错误修复: 不能传 undefined，需要明确设置为 false 对象来表示无箭头
        GRAPH_STORE.inventory = initOneGraph('viz-inventory', {
            edges: {
                arrows: { to: { enabled: false }, from: { enabled: false } },
                color: '#d2a8ff'
            },
            nodes: { shape: 'box', margin: 10 }
        });

        // 3. Narrative:
        // 错误修复: 没有 "style" 这个属性，实现虚线应该用 "dashes: true"
        GRAPH_STORE.narrative = initOneGraph('viz-narrative', {
            edges: {
                arrows: 'to',
                color: '#ffcc00',
                dashes: true // 这里改成了 dashes
            },
            layout: { hierarchical: { direction: 'UD', sortMethod: 'directed', levelSeparation: 60 } }
        });
    }
    // ==========================================
    // 3. 提示词工程 (System + User Injection)
    // ==========================================

    const SYSTEM_PROMPT = `
你是一个赛博朋克风格文字冒险游戏的后端引擎。包含“竞争对手系统”。

【核心规则】
1. **关键点 (Keypoints)**：每个关卡有一组特定的关键物品/情报。
   - **判定严格性**：只有当玩家明确执行了获取操作（如“搜索尸体”、“黑入电脑”、“撬开保险箱”）且逻辑合理时，才能判定玩家获得了 Keypoint。简单的“查看房间”或“去那里”**不能**获得关键点。
   - 如果玩家操作模糊，请提示玩家发现了一些线索，但需要更具体的互动。
2. **Boss (Rival Agent 'Phantom')**：
   - 有一个名为 Phantom 的竞争对手在地图上移动。
   - 每次玩家行动后，Boss 有中等概率 (30%-50%) 移动或行动。
   - 如果 Boss 到达藏有未发现 Keypoint 的地点，Boss 可能会抢先拿走它（标记为 boss_owned）。
   - 如果 Boss 和玩家在同一地点，且 Boss 持有 Keypoint，玩家可以尝试攻击/偷窃夺回。
3. **图谱管理**：
   - Location: 必须高亮玩家(青色)和Boss(红色)的位置。
   - Inventory: 玩家获得 Keypoint 时加入 Inventory。
   - Narrative: 记录重要事件。

【输出要求】
必须严格遵守 JSON 格式。
`;

    function getJsonInstruction() {
        return `
\n\n[SYSTEM INSTRUCTION]
必须严格遵守以下 JSON 格式回复（不要Markdown）：
{
  "narrative": "剧情文本 (HTML格式)",
  "boss_action": "Boss的行动描述 (如 'Phantom 闯入了服务器室...')，无行动则为 null",
  "boss_location_id": "Boss当前/新位置的节点ID (需存在于Location图中)",
  "current_location_id": "玩家当前位置ID",
  "keypoint_updates": [
    { "id": "Keypoint ID (from Context)", "status": "player" | "boss" }
  ],
  "stage_complete": boolean (是否收集够了本关卡所需的数量),
  "game_over": boolean,
  "ending_type": "VICTORY" | "DEFEAT" | null,
  "graph_ops": [
    {
      "domain": "location" | "inventory" | "narrative",
      "op": "add_node" | "add_edge" | "remove_node",
      "id": "...", "label": "...", "desc": "...", "from": "...", "to": "..."
    }
  ]
}
`;
    }

    // 动态生成包含游戏状态的 Context
    function getGameContext(userAction) {
        const graphSnap = {};
        ['location', 'inventory', 'narrative'].forEach(key => {
            graphSnap[key] = {
                nodes: GRAPH_STORE[key].nodes.get().map(n => ({id: n.id, label: n.label})),
                edges: GRAPH_STORE[key].edges.get().map(e => ({from: e.from, to: e.to}))
            };
        });

        // 过滤出当前关卡未完成的任务
        const stageInfo = STAGE_CONFIG[gameState.currentStage];
        const kpStatus = gameState.keypoints.map(k => `${k.id} (${k.name}): ${k.status} [Desc: ${k.desc}]`).join("\n");
        const bossInfo = `Boss Location: ${gameState.bossLocationId}`;

        const context = `
[Current Stage]: ${gameState.currentStage} - ${stageInfo.name}
[Objective]: Collect ${stageInfo.required_count} Keypoints.
[Keypoints Status]:
${kpStatus}
[Rival Info]: ${bossInfo}
[Graph State]: ${JSON.stringify(graphSnap)}
`;
        return context;
    }

    // ==========================================
    // 4. LLM 通信 & 处理
    // ==========================================

    async function callLLM(userAction, isInit = false) {
        const loading = document.getElementById('scan-effect');
        loading.classList.add('scanning');

        let userContent = "";
        const instruction = getJsonInstruction();

        if (isInit) {
            // 初始化特定关卡
            const s1 = STAGE_CONFIG[1];
            userContent = `初始化游戏 Stage 1: ${s1.name}。
            1. Location图: 创建起点(贫民窟), 和几个分支地点(诊所, 酒吧, 暗巷)。Boss初始位置在${s1.boss_start}。
            2. Inventory图: 玩家初始空。
            3. Narrative图: 起点事件(接受任务)。
            4. 告知玩家本关卡有3个潜在目标，需要找到其中 ${s1.required_count} 个。
            ` + instruction;
        } else {
            const context = getGameContext(userAction);
            userContent = `[Context] ${context}\n\n[Player Action] ${userAction}\n` +
                `Reminder: Be strict. Player only gets Keypoint if action is specific to the item description.` +
                instruction;
        }

        const messages = [
            { role: "system", content: SYSTEM_PROMPT },
            ...conversationHistory,
            { role: "user", content: userContent }
        ];

        try {
            const response = await fetch(API_CONFIG.url, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${API_CONFIG.key}`
                },
                body: JSON.stringify({
                    model: API_CONFIG.model,
                    messages: messages,
                    temperature: 0.7, // 稍微高一点让Boss行为随机
                    response_format: { type: "json_object" }
                })
            });

            if (!response.ok) throw new Error("API Error");
            const data = await response.json();
            const cleanContent = data.choices[0].message.content.replace(/```json/g, '').replace(/```/g, '').trim();

            console.log("LLM Response:", cleanContent); // Debug

            const result = JSON.parse(cleanContent);

            if (!isInit) conversationHistory.push({ role: "user", content: userAction });
            // 简略保存历史
            conversationHistory.push({ role: "assistant", content: JSON.stringify({narrative: result.narrative, boss_action: result.boss_action}) });
            if (conversationHistory.length > 10) conversationHistory = [conversationHistory[0], ...conversationHistory.slice(-9)];

            return result;
        } catch (error) {
            console.error(error);
            appendLog(`System Error: ${error.message}`, 'system');
            return null;
        } finally {
            loading.classList.remove('scanning');
        }
    }

    // 核心逻辑处理
    async function processGameResponse(data) {
        if (!data) return;

        // 1. 图谱操作
        if (data.graph_ops) data.graph_ops.forEach(op => executeOp(op));

        // 2. 更新状态
        if (data.current_location_id) gameState.currentLocationId = data.current_location_id;
        if (data.boss_location_id) gameState.bossLocationId = data.boss_location_id;

        // 3. 关键点更新逻辑
        if (data.keypoint_updates && data.keypoint_updates.length > 0) {
            data.keypoint_updates.forEach(update => {
                const kp = gameState.keypoints.find(k => k.id === update.id);
                if (kp) {
                    kp.status = update.status;
                    // 如果玩家获得了，添加到 Inventory 图
                    if (update.status === 'player') {
                        executeOp({ domain: 'inventory', op: 'add_node', id: kp.id, label: kp.name, desc: kp.desc });
                        executeOp({ domain: 'inventory', op: 'add_edge', from: 'player_node', to: kp.id, label: '持有' });
                    }
                }
            });
            updateKeypointUI();
        }

        // 4. 显示文本
        appendLog(data.narrative, 'ai');
        if (data.boss_action) {
            appendLog(`[RIVAL ACTIVITY] ${data.boss_action}`, 'boss');
        }

        // 5. 视觉更新
        highlightNodes();

        // 6. 关卡判定
        if (data.stage_complete) {
            await handleStageClear();
            return; // 暂停后续处理
        }

        // 7. 游戏结束判定
        if (data.game_over) {
            gameState.isGameOver = true;
            const endMsg = data.ending_type === 'VICTORY' ? "任务完成 // 完美潜入" : "任务失败 // 信号丢失";
            appendLog(endMsg, 'stage-clear'); // 复用样式
            toggleInputs(false);
        }
    }

    // 过关逻辑
    async function handleStageClear() {
        toggleInputs(false);
        appendLog(`>> STAGE ${gameState.currentStage} COMPLETE. UPLOADING DATA...`, 'stage-clear');

        if (gameState.currentStage >= gameState.maxStages) {
            appendLog("所有阶段任务完成！恭喜通关。", 'stage-clear');
            return;
        }

        // 延迟进入下一关
        setTimeout(async () => {
            gameState.currentStage++;
            initStage(gameState.currentStage);

            // 发送过场请求
            const stageConfig = STAGE_CONFIG[gameState.currentStage];
            const prompt = `玩家完成了上一关。现在进入 Stage ${gameState.currentStage}: ${stageConfig.name}。
            请重置 Location 图(除了玩家节点)，生成新的地图结构(公司广场风格)。
            重置 Inventory 图(保留上一关的关键道具)。
            Boss 出现在新位置 ${stageConfig.boss_start}。
            描述新环境。`;

            // 这里我们手动构造一次特殊的调用
            conversationHistory = []; // 清空历史，新关卡新气象
            const result = await callLLM(prompt, false); // 这里的false是因为不想重置所有逻辑，只想作为一次特殊指令
            processGameResponse(result);
            toggleInputs(true);
        }, 2000);
    }

    // 初始化特定关卡数据
    function initStage(stageNum) {
        document.getElementById('stage-display').innerText = `STAGE ${stageNum}`;
        const config = STAGE_CONFIG[stageNum];

        // 深拷贝关键点数据
        gameState.keypoints = JSON.parse(JSON.stringify(config.keypoints));
        gameState.bossLocationId = config.boss_start;

        document.getElementById('objective-display').innerText = `目标: 获取 ${config.required_count} 个关键数据`;
        updateKeypointUI();
    }

    // 更新右侧情报面板
    function updateKeypointUI() {
        const container = document.getElementById('keypoint-list-container');
        container.innerHTML = '';

        gameState.keypoints.forEach(kp => {
            const div = document.createElement('div');
            let statusClass = 'unknown';
            let icon = '❓';

            if (kp.status === 'player') { statusClass = 'player-owned'; icon = '✅'; }
            else if (kp.status === 'boss') { statusClass = 'boss-owned'; icon = '⚠️'; }

            div.className = `keypoint-item ${statusClass}`;
            div.innerHTML = `
                <span>${icon} ${kp.name}</span>
                <span style="font-size:0.7rem; opacity:0.7">${kp.status.toUpperCase()}</span>
            `;
            container.appendChild(div);
        });
    }

    // 执行图操作
    function executeOp(op) {
        const domain = op.domain;
        if (!GRAPH_STORE[domain]) return;
        const { nodes, edges } = GRAPH_STORE[domain];

        try {
            if (op.op === 'add_node') {
                if (!nodes.get(op.id)) {
                    nodes.add({
                        id: op.id,
                        label: op.label,
                        title: op.desc,
                        color: op.color || getColorByDomain(domain)
                    });
                }
            } else if (op.op === 'add_edge') {
                const exists = edges.get({ filter: e => e.from === op.from && e.to === op.to });
                if (exists.length === 0) {
                    edges.add({ from: op.from, to: op.to, label: op.label });
                }
            } else if (op.op === 'remove_node') {
                nodes.remove(op.id);
            }
        } catch (e) { console.warn("Op error", e); }
    }

    function getColorByDomain(domain) {
        if (domain === 'location') return '#4a9eff';
        if (domain === 'inventory') return '#d2a8ff';
        if (domain === 'narrative') return '#ffcc00';
        return '#fff';
    }

    // 高亮逻辑：玩家青色，Boss红色
    function highlightNodes() {
        const nodes = GRAPH_STORE.location.nodes;
        const updates = [];

        nodes.getIds().forEach(id => {
            let color = '#4a9eff'; // 默认蓝
            let size = 15;
            let borderWidth = 2;
            let borderColor = '#233142';

            if (id === gameState.currentLocationId) {
                color = '#00ffcc'; // 玩家青
                size = 25;
            }
            if (id === gameState.bossLocationId) {
                if (id === gameState.currentLocationId) {
                    // 遭遇战！
                    borderColor = '#ff3366';
                    borderWidth = 5;
                } else {
                    color = '#ff3366'; // Boss 红
                    size = 20;
                }
            }

            updates.push({ id, color: { background: color, border: borderColor }, size, borderWidth });
        });
        nodes.update(updates);

        if (gameState.currentLocationId) {
            GRAPH_STORE.location.network.fit({ nodes: [gameState.currentLocationId], animation: true });
        }
    }

    // ==========================================
    // 5. 交互
    // ==========================================

    function appendLog(html, type) {
        const box = document.getElementById('chat-history');
        const div = document.createElement('div');
        div.className = `msg ${type}`;
        div.innerHTML = html;
        box.appendChild(div);
        box.scrollTop = box.scrollHeight;
    }

    async function handleInput() {
        if (gameState.isGameOver) return;
        const input = document.getElementById('player-input');
        const val = input.value.trim();
        if (!val) return;

        appendLog(val, 'user');
        input.value = '';
        toggleInputs(false);

        const result = await callLLM(val);
        await processGameResponse(result);

        if (!gameState.isGameOver) toggleInputs(true);
    }

    function toggleInputs(enabled) {
        document.getElementById('player-input').disabled = !enabled;
        document.getElementById('send-btn').disabled = !enabled;
        if (enabled) document.getElementById('player-input').focus();
    }

    async function startGame() {
        gameState.isGameOver = false;
        gameState.currentStage = 1;
        conversationHistory = [];

        // 清空图
        Object.values(GRAPH_STORE).forEach(g => {
            if(g.nodes) g.nodes.clear();
            if(g.edges) g.edges.clear();
        });

        // 预设玩家节点到 Inventory
        GRAPH_STORE.inventory.nodes.add({id: 'player_node', label: 'Player', color: '#fff', shape: 'diamond'});

        document.getElementById('chat-history').innerHTML = '<div class="msg system">>> 连接神经网... 载入 Rival 模块...</div>';
        toggleInputs(false);

        initStage(1);

        const result = await callLLM(null, true);
        await processGameResponse(result);

        toggleInputs(true);
    }

    document.getElementById('player-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') handleInput();
    });

    window.onload = function() {
        initAllGraphs();
        startGame();
    };

</script>
</body>
</html>