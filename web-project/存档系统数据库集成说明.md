# 存档系统数据库集成说明

## 更新内容

✅ 已将存档系统从 localStorage 迁移到 MongoDB 数据库

## 主要改动

### 1. 存档数据现在保存到数据库

**API端点：** `PUT /api/mongo/game-saves/player/:playerId/slot/:saveSlot`

**发送数据格式：**
```javascript
{
  scriptId: 'fate-prologue',
  saveName: '场景描述或标题',
  description: '进度: 50%, 选择: 3次',
  currentSceneIndex: 10,
  gameVariables: {
    choice_4: { index: 0, text: '选择Saber', jumpTo: 10 }
  },
  readScenes: [0, 1, 2, 4, 10]
}
```

**数据库存储结构：**
```javascript
{
  playerId: 'player_1234567890',
  saveSlot: 1,
  saveName: '选择召唤Saber',
  description: '进度: 50%, 选择: 3次',
  scriptId: 'fate-prologue',
  currentSceneIndex: 10,
  sceneSnapshot: {
    speaker: 'Saber',
    text: '问你一句，你就是我的Master吗？',
    bgImage: '...',
    timestamp: '2024-12-09T12:00:00Z'
  },
  progressPercentage: 50,
  gameVariables: { ... },
  readScenes: [0, 1, 2, 4, 10],
  unlockedContent: {
    cg: [],
    achievements: [],
    endings: []
  },
  playTime: 0,
  isAutoSave: false,
  isQuickSave: false,
  isValid: true,
  gameVersion: '1.0.0',
  createdAt: '2024-12-09T12:00:00Z',
  updatedAt: '2024-12-09T12:05:00Z'
}
```

### 2. 读档从数据库读取

**API端点：** `GET /api/mongo/game-saves/player/:playerId/slot/:saveSlot`

**返回数据格式：**
```javascript
{
  success: true,
  data: {
    playerId: 'player_1234567890',
    saveSlot: 1,
    saveName: '选择召唤Saber',
    currentSceneIndex: 10,
    gameVariables: { ... },
    readScenes: [0, 1, 2, 4, 10],
    sceneSnapshot: { ... },
    progressPercentage: 50,
    updatedAt: '2024-12-09T12:05:00Z'
  }
}
```

### 3. 获取存档列表

**API端点：** `GET /api/mongo/game-saves/player/:playerId`

**查询参数：**
- `includeAuto`: 是否包含自动存档（默认true）
- `includeQuick`: 是否包含快速存档（默认true）

### 4. 快速存档

**API端点：** `POST /api/mongo/game-saves/player/:playerId/quicksave`

- 自动使用槽位99
- 标记为 `isQuickSave: true`

### 5. 自动存档

**API端点：** `POST /api/mongo/game-saves/player/:playerId/autosave`

- 自动使用槽位98
- 标记为 `isAutoSave: true`
- 每推进5个场景自动触发

## 功能对比

### 之前（localStorage）

```javascript
// 存档
localStorage.setItem('save_player_script_1', JSON.stringify(data));

// 读档
const data = JSON.parse(localStorage.getItem('save_player_script_1'));
```

**缺点：**
- ❌ 数据保存在浏览器本地，清除缓存会丢失
- ❌ 无法跨设备同步
- ❌ 无法在服务器端管理
- ❌ 容量限制（5-10MB）

### 现在（MongoDB）

```javascript
// 存档
await axios.put(`/api/mongo/game-saves/player/${playerId}/slot/${slot}`, data);

// 读档
const response = await axios.get(`/api/mongo/game-saves/player/${playerId}/slot/${slot}`);
```

**优点：**
- ✅ 数据永久保存在服务器
- ✅ 可以跨设备访问（使用同一playerId）
- ✅ 服务器端可以管理和备份
- ✅ 无容量限制
- ✅ 支持数据统计和分析

## 使用方法

### 1. 启动后端服务

```bash
cd backend
node src/app.js
```

确保 MongoDB 服务已启动并连接成功。

### 2. 启动前端

```bash
cd web-project
npm run dev
```

### 3. 访问页面

```
http://localhost:5173/novel-show?scriptId=fate-prologue&playerId=player123
```

**重要：** 现在必须指定 `playerId`，相同的 playerId 可以访问相同的存档。

### 4. 测试存档

1. 进行游戏，做几个选择
2. 点击菜单 → 存档 → 选择槽位1
3. 刷新页面
4. 点击菜单 → 读档 → 选择槽位1
5. 游戏恢复到保存时的状态

### 5. 检查数据库

使用 MongoDB Compass 或命令行查看：

```javascript
// 连接MongoDB
mongo mongodb://localhost:27017/novel_reading_db

// 查看存档集合
db.game_saves.find().pretty()

// 查询特定玩家的存档
db.game_saves.find({ playerId: "player123" }).pretty()

// 查看存档数量
db.game_saves.countDocuments()
```

## 数据结构映射

### 前端 → 后端

| 前端字段 | 后端字段 | 说明 |
|---------|---------|------|
| currentScene.index | currentSceneIndex | 当前场景索引 |
| choiceHistory | readScenes | 已读场景列表 |
| gameVariables | gameVariables | 游戏变量 |
| - | sceneSnapshot | 自动生成的场景快照 |
| - | progressPercentage | 自动计算的进度 |

### 后端 → 前端

读档时需要映射：
```javascript
// 后端返回的 currentSceneIndex 是场景的 index 字段
// 需要在 storyScript 数组中查找对应的位置
const targetIndex = storyScript.value.findIndex(
  scene => scene.index === saveData.currentSceneIndex
);
currentIndex.value = targetIndex;
```

## API错误处理

### 存档失败

可能的错误：
1. **剧本不存在** (400): 检查 scriptId 是否正确
2. **场景索引无效** (400): 检查场景数据是否完整
3. **服务器错误** (500): 检查后端日志

示例：
```javascript
try {
  await saveToSlot(1);
} catch (error) {
  if (error.response?.status === 400) {
    alert('存档数据无效');
  } else {
    alert('服务器错误，请稍后重试');
  }
}
```

### 读档失败

可能的错误：
1. **存档不存在** (404): 该槽位没有存档
2. **场景不存在**: 存档的场景索引在当前剧本中找不到
3. **数据格式错误**: 存档数据损坏

## 多玩家支持

### 使用不同的 playerId

```javascript
// 玩家1
http://localhost:5173/novel-show?playerId=alice

// 玩家2
http://localhost:5173/novel-show?playerId=bob
```

每个 playerId 拥有独立的10个存档槽位。

### 生成唯一 playerId

```javascript
// 方法1: 时间戳
const playerId = 'player_' + Date.now();

// 方法2: 随机字符串
const playerId = 'player_' + Math.random().toString(36).substr(2, 9);

// 方法3: 用户登录后使用用户ID
const playerId = 'user_' + userId;
```

## 安全考虑

### 当前实现（开发环境）

- ⚠️ playerId 可以任意指定
- ⚠️ 没有身份验证
- ⚠️ 任何人都可以访问任何玩家的存档

### 生产环境建议

1. **添加用户认证**：
```javascript
// 在后端添加认证中间件
router.use(authenticateUser);

// 验证 playerId 属于当前登录用户
if (req.user.id !== req.params.playerId) {
  return res.status(403).json({ message: '无权访问' });
}
```

2. **使用 JWT Token**：
```javascript
// 前端请求时携带 token
axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;
```

3. **添加速率限制**：
```javascript
// 防止频繁存档
const saveRateLimit = rateLimit({
  windowMs: 60 * 1000, // 1分钟
  max: 10 // 最多10次
});
router.put('/player/:playerId/slot/:saveSlot', saveRateLimit, saveGame);
```

## 性能优化

### 1. 存档列表缓存

```javascript
// 页面加载时一次性获取所有存档
const loadSavesList = async () => {
  const response = await axios.get(`/api/mongo/game-saves/player/${playerId}`);
  localSaves.value = response.data.data;
};

// 后续操作使用缓存，减少请求
const getSaveInfo = (slot) => {
  return localSaves.value[slot];
};
```

### 2. 批量预加载

```javascript
// 预加载存档的场景图片
const preloadSaveImages = async () => {
  for (const save of Object.values(localSaves.value)) {
    if (save.sceneSnapshot?.bgImage) {
      preloadImage(save.sceneSnapshot.bgImage);
    }
  }
};
```

### 3. 自动存档节流

```javascript
// 避免频繁自动存档
let lastAutoSaveTime = 0;
const autoSaveGame = async () => {
  const now = Date.now();
  if (now - lastAutoSaveTime < 30000) { // 30秒内不重复
    return;
  }
  lastAutoSaveTime = now;
  // 执行存档...
};
```

## 故障排除

### 问题1: 存档后刷新页面，存档列表为空

**原因：** 前端缓存没有更新

**解决：**
```javascript
// 存档成功后更新缓存
if (response.data.success) {
  localSaves.value[slot] = response.data.data;
}
```

### 问题2: 读档后场景显示错误

**原因：** currentSceneIndex 和数组索引混淆

**解决：**
```javascript
// 使用 findIndex 查找场景
const targetIndex = storyScript.value.findIndex(
  scene => scene.index === saveData.currentSceneIndex
);
```

### 问题3: 跨设备存档不同步

**原因：** playerId 不一致

**解决：** 使用统一的用户登录系统，确保 playerId 一致。

### 问题4: MongoDB 连接失败

**检查：**
1. MongoDB 服务是否启动
2. 连接字符串是否正确
3. 数据库是否有权限

```bash
# 检查 MongoDB 服务
net start | find "MongoDB"

# 测试连接
mongo mongodb://localhost:27017/novel_reading_db
```

## 未来扩展

### 1. 云存档同步

```javascript
// 支持自动同步到云端
const syncToCloud = async () => {
  await axios.post('/api/sync/save', localSaves.value);
};
```

### 2. 存档导入/导出

```javascript
// 导出存档为JSON
const exportSave = (slot) => {
  const save = localSaves.value[slot];
  const blob = new Blob([JSON.stringify(save, null, 2)], 
    { type: 'application/json' });
  downloadBlob(blob, `save_${slot}.json`);
};

// 导入存档
const importSave = async (file) => {
  const data = JSON.parse(await file.text());
  await saveToSlot(data.saveSlot, data);
};
```

### 3. 存档分享

```javascript
// 生成分享码
const shareSave = async (slot) => {
  const response = await axios.post(`/api/share/save/${slot}`);
  return response.data.shareCode; // "ABC123"
};

// 使用分享码加载
const loadSharedSave = async (shareCode) => {
  const response = await axios.get(`/api/share/load/${shareCode}`);
  // 加载存档...
};
```

## 总结

✅ 存档系统已成功迁移到 MongoDB 数据库
✅ 支持10个手动存档槽位
✅ 支持快速存档和自动存档
✅ 数据永久保存，可跨设备访问
✅ 完整的错误处理和用户反馈

📋 下一步：
- [ ] 添加用户认证系统
- [ ] 实现云存档同步
- [ ] 添加存档统计和分析
- [ ] 实现存档导入/导出功能

---

更新时间：2024-12-09
版本：2.0.0









