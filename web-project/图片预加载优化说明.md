# 图片预加载优化说明

## 优化策略

实现了**混合预加载策略**：
1. ⚡ **优先预加载**：前5张图片（阻塞式）
2. 🔄 **后台预加载**：剩余图片（非阻塞、分批加载）

## 工作原理

### 1. 优先预加载（Eager Loading）

```javascript
// 加载剧本后，立即预加载前5张图片
const priorityCount = Math.min(5, scenes.length);
await preloadImagesInBatch(priorityImages);
```

**特点：**
- ✅ 阻塞式加载，确保前5个场景切换流畅
- ✅ 用户可以立即开始游戏
- ✅ 大约需要1-3秒（取决于图片大小和网速）

### 2. 后台预加载（Lazy Loading）

```javascript
// 游戏开始后，后台逐步加载剩余图片
preloadRemainingImages(scenes, priorityCount);
```

**特点：**
- ✅ 非阻塞，不影响游戏体验
- ✅ 分批加载（每批3张）
- ✅ 批次间隔500ms，避免占用太多带宽
- ✅ 延迟1秒启动，优先保证游戏渲染

## 预加载流程

```
用户访问页面
    ↓
加载剧本数据
    ↓
【阻塞】预加载前5张图片 (1-3秒)
    ↓
显示游戏界面（用户可以开始游戏）
    ↓
【后台】延迟1秒后开始预加载
    ↓
【后台】每次加载3张，间隔500ms
    ↓
所有图片预加载完成
```

## 性能数据

假设剧本有30个场景，每张图片500KB，网速10Mbps：

| 阶段 | 数量 | 大小 | 时间 | 用户体验 |
|------|------|------|------|----------|
| 优先预加载 | 5张 | 2.5MB | ~2秒 | 等待中 |
| 游戏开始 | - | - | 0秒 | ✅ 可以玩了 |
| 后台预加载 | 25张 | 12.5MB | ~15秒 | 🎮 正在游戏中 |

**对比：全部预加载**
- 需要等待 ~17秒才能开始游戏 ❌

**对比：只加载第一张**
- 立即开始，但每次切换都要等待 ❌

## 代码实现

### 核心函数

#### 1. preloadImage()
```javascript
const preloadImage = (url) => {
  // 避免重复加载
  if (preloadedImages.value.has(url)) {
    return Promise.resolve();
  }
  
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      preloadedImages.value.add(url); // 标记已加载
      preloadProgress.value.loaded++; // 更新进度
      resolve(img);
    };
    img.onerror = () => {
      preloadProgress.value.loaded++;
      resolve(); // 失败也继续，不阻塞
    };
    img.src = url;
  });
};
```

#### 2. preloadImagesInBatch()
```javascript
const preloadImagesInBatch = async (urls) => {
  // 并行加载多张图片
  await Promise.all(urls.map(url => preloadImage(url)));
};
```

#### 3. preloadRemainingImages()
```javascript
const preloadRemainingImages = async (scenes, startIndex) => {
  // 延迟1秒，避免影响初始渲染
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  // 分批加载，每批3张
  const batchSize = 3;
  for (let i = startIndex; i < scenes.length; i += batchSize) {
    const batch = remainingUrls.slice(i, i + batchSize);
    await preloadImagesInBatch(batch);
    
    // 批次间隔500ms
    await new Promise(resolve => setTimeout(resolve, 500));
  }
};
```

## 状态追踪

### preloadedImages (Set)
存储已预加载的图片URL，避免重复加载：
```javascript
preloadedImages.value = new Set([
  'https://example.com/image1.jpg',
  'https://example.com/image2.jpg'
]);
```

### preloadProgress (Object)
追踪预加载进度：
```javascript
preloadProgress.value = {
  loaded: 8,   // 已加载数量
  total: 30    // 总图片数量
};
```

## 调试信息

启用调试模式（`?debug=true`）可以看到：
```
图片预加载: 8/30
预加载进度: 27%
```

控制台日志：
```
正在预加载前 5 张图片...
优先图片预加载完成: 5 张
启动后台预加载，剩余 25 张图片
后台预加载队列: 25 张图片
后台预加载进度: 8/30
后台预加载进度: 11/30
...
✅ 所有图片预加载完成: 30/30
```

## 配置参数

可以调整这些参数来优化不同场景：

### 优先预加载数量
```javascript
const priorityCount = Math.min(5, scenes.length); // 可改为 3、7、10 等
```

**建议：**
- 短剧本（<10场景）：预加载全部
- 中剧本（10-30场景）：预加载 5-7 张
- 长剧本（>30场景）：预加载 3-5 张

### 批次大小
```javascript
const batchSize = 3; // 可改为 2、5 等
```

**建议：**
- 快速网络：5张/批
- 中等网络：3张/批
- 慢速网络：2张/批

### 批次间隔
```javascript
await new Promise(resolve => setTimeout(resolve, 500)); // 可改为 300、1000 等
```

**建议：**
- 快速网络：300ms
- 中等网络：500ms
- 慢速网络：1000ms

### 启动延迟
```javascript
await new Promise(resolve => setTimeout(resolve, 1000)); // 可改为 500、2000 等
```

**建议：**
- 性能好的设备：500ms
- 中等设备：1000ms
- 低端设备：2000ms

## 优化效果对比

### 场景：30个场景的剧本

| 策略 | 初始等待 | 第2个场景 | 第6个场景 | 第30个场景 |
|------|---------|-----------|-----------|------------|
| 只加载第一张 | ✅ 0.5秒 | ❌ 等待0.5秒 | ❌ 等待0.5秒 | ❌ 等待0.5秒 |
| 全部预加载 | ❌ 15秒 | ✅ 立即 | ✅ 立即 | ✅ 立即 |
| **混合策略** | ✅ 2秒 | ✅ 立即 | ✅ 立即 | ✅ 立即* |

\* 如果玩家玩得很快，可能第30个场景还在后台加载中，会有短暂等待

## 进一步优化建议

### 1. 动态预加载（根据用户行为）
```javascript
// 预测用户下一步，预加载相邻场景
const preloadAdjacentScenes = (currentIndex) => {
  const nextScenes = [
    storyScript.value[currentIndex + 1],
    storyScript.value[currentIndex + 2]
  ];
  // 预加载这些场景的图片
};
```

### 2. 根据网络速度调整策略
```javascript
// 使用 Network Information API
if (navigator.connection?.effectiveType === '4g') {
  priorityCount = 10; // 快速网络，多预加载
} else if (navigator.connection?.effectiveType === '3g') {
  priorityCount = 5;  // 中等网络
} else {
  priorityCount = 3;  // 慢速网络
}
```

### 3. 使用 Service Worker 缓存
```javascript
// 永久缓存已加载的图片
self.addEventListener('fetch', event => {
  if (event.request.url.match(/\.(jpg|png|webp)$/)) {
    event.respondWith(
      caches.match(event.request)
        .then(response => response || fetch(event.request))
    );
  }
});
```

### 4. 图片压缩和格式优化
- 使用 WebP 格式（比 JPEG 小30%）
- 提供多种尺寸（响应式图片）
- 使用 CDN 加速

### 5. 渐进式 JPEG
```javascript
// 先加载低质量版本，再加载高质量版本
const preloadProgressiveImage = (url) => {
  // 先加载缩略图
  const thumbnail = url.replace('.jpg', '_thumb.jpg');
  preloadImage(thumbnail);
  // 后台加载原图
  setTimeout(() => preloadImage(url), 1000);
};
```

## 测试方法

### 1. 本地测试
```bash
# 启动开发服务器
npm run dev

# 访问并开启调试
http://localhost:5173/novel-show?debug=true
```

观察控制台日志和调试面板的预加载进度。

### 2. 模拟慢速网络
Chrome DevTools → Network → Throttling → Slow 3G

观察在慢速网络下的加载体验。

### 3. 监控加载时间
```javascript
// 在 loadScript() 中添加
const startTime = performance.now();
await preloadImagesInBatch(priorityImages);
const loadTime = performance.now() - startTime;
console.log(`优先图片加载耗时: ${loadTime.toFixed(0)}ms`);
```

## 常见问题

### Q1: 为什么选择预加载5张？
**A:** 这是一个平衡点：
- 不会让用户等太久（2-3秒）
- 足够覆盖前几个场景的切换
- 对大多数剧本都适用

### Q2: 后台加载会影响游戏性能吗？
**A:** 几乎不会：
- 使用间隔和分批加载
- 不阻塞主线程
- 如果性能不佳，浏览器会自动降低优先级

### Q3: 图片加载失败怎么办？
**A:** 已处理：
- 失败不会阻塞其他图片
- 继续计入进度
- 实际显示时浏览器会重试

### Q4: 可以取消后台加载吗？
**A:** 可以添加取消机制：
```javascript
let abortController = new AbortController();

// 取消加载
const cancelPreload = () => {
  abortController.abort();
};
```

### Q5: 移动端需要调整参数吗？
**A:** 建议：
- 减少优先预加载数量（3张）
- 增加批次间隔（1000ms）
- 检测网络状态后动态调整

## 总结

**优点：**
- ✅ 快速启动（2-3秒）
- ✅ 流畅体验（前5个场景无等待）
- ✅ 节省带宽（分批加载）
- ✅ 容错性好（失败不阻塞）
- ✅ 可配置（根据需求调整）

**适用场景：**
- ✅ 中大型剧本（>10个场景）
- ✅ 图片较大的项目
- ✅ 需要快速启动的场景
- ✅ 网络状况不稳定的用户

---

更新时间：2024-12-09
版本：1.0.0














