<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SILENT HAZE</title>
    <style>
        /* 全局重置样式 */
        * {
            margin: 0;                    /* 清除所有外边距 */
            padding: 0;                   /* 清除所有内边距 */
            box-sizing: border-box;       /* 使padding和border包含在宽高内 */
        }

        /* 页面主体样式 */
        body {
            font-family: 'Arial', 'Microsoft YaHei', sans-serif;  /* 设置字体族，优先Arial，中文使用微软雅黑 */
            overflow: hidden;                                      /* 隐藏滚动条，防止页面滚动 */
            background: #E1F5FE;                                   /* 设置浅蓝色背景色 */
            position: relative;                                    /* 相对定位，作为子元素的定位参考 */
            opacity: 1;                                            /* 初始透明度为1，立即显示背景 */
            transform: scale(1);                                   /* 初始正常大小 */
            transition: none;                                      /* 移除初始过渡动画，避免白屏 */
        }

        /* 页面加载完成后的样式 */
        body.loaded {
            opacity: 1;                                            /* 完全不透明 */
            transform: scale(1);                                   /* 正常大小 */
        }

        /* 左侧模糊背景层 - 使用雨天图片 */
        .left-blur-bg {
            position: fixed;              /* 固定定位，不随页面滚动 */
            top: 0;                       /* 距离顶部0像素 */
            left: 0;                      /* 距离左侧0像素 */
            width: 50%;                   /* 宽度占屏幕的50% */
            height: 100%;                 /* 高度占满整个视口 */
            z-index: -3;                  /* 层级为-3，位于最底层 */
            overflow: hidden;             /* 隐藏超出容器的内容 */
            opacity: 1 !important;        /* 强制显示，避免被其他样式覆盖 */
        }

        /* 左侧背景的伪元素 - 创建实际的模糊背景图片 */
        .left-blur-bg::before {
            content: '';                                          /* 伪元素必须有content属性 */
            position: absolute;                                   /* 绝对定位相对于父容器 */
            top: -10%;                                            /* 向上扩展10%，防止边缘露出 */
            left: -10%;                                           /* 向左扩展10%，防止边缘露出 */
            width: 120%;                                          /* 宽度120%，超出父容器 */
            height: 120%;                                         /* 高度120%，超出父容器 */
            background-image: url('./backgroundLeft.jpg');       /* 设置雨天背景图片 */
            background-size: cover;                               /* 背景图片覆盖整个区域 */
            background-position: center;                          /* 背景图片居中显示 */
            filter: blur(30px) brightness(1.1) saturate(0.8);    /* 模糊30px，亮度1.1，饱和度0.8 */
            transform: scale(1.2);                                /* 初始缩放1.2倍 */
            animation: leftBgFloat 20s ease-in-out infinite;     /* 应用动画：20秒周期，缓入缓出，无限循环 */
            will-change: transform, filter, background-position;  /* 优化性能：提前告知浏览器这些属性会变化 */
            transition: animation-duration 0.3s ease-in-out;      /* 动画持续时间变化时的过渡效果0.3秒 */
        }

        /* 左侧背景动画：缓慢浮动缩放和轻微旋转 */
        @keyframes leftBgFloat {
            0% {                                                  /* 动画起始状态 */
                transform: scale(1.2) rotate(0deg);              /* 缩放1.2倍，无旋转 */
                filter: blur(25px) brightness(0.8) saturate(0.8);  /* 模糊30px */
            }
            25% {                                                 /* 动画进行到25%时 */
                transform: scale(1.25) rotate(1deg);             /* 缩放1.25倍，顺时针旋转1度 */
                filter: blur(27px) brightness(0.85) saturate(0.85);  /* 增加模糊和亮度 */
            }
            50% {                                                 /* 动画进行到50%时（中点） */
                transform: scale(1.3) rotate(0deg);              /* 最大缩放1.3倍，回到无旋转 */
                filter: blur(30px) brightness(0.9) saturate(0.9);  /* 最大模糊和亮度 */
            }
            75% {                                                 /* 动画进行到75%时 */
                transform: scale(1.25) rotate(-1deg);            /* 缩放1.25倍，逆时针旋转1度 */
                filter: blur(27px) brightness(0.85) saturate(0.85);  /* 减少模糊和亮度 */
            }
            100% {                                                /* 动画结束状态（回到起始） */
                transform: scale(1.2) rotate(0deg);              /* 恢复到初始状态 */
                filter: blur(25px) brightness(0.8) saturate(0.8);  /* 恢复到初始滤镜 */
            }
        }

        /* 左侧背景悬停加强动画 - 鼠标悬停时触发更快速的动画 */
        .left-blur-bg:hover::before {
            animation: leftBgFloatIntense 8s ease-in-out infinite;  /* 悬停时切换到8秒周期的加强动画 */
        }

        /* 左侧背景加强动画关键帧 - 更大的缩放和旋转幅度 */
        @keyframes leftBgFloatIntense {
            0% {                                                  /* 动画起始 */
                transform: scale(1.3) rotate(0deg);              /* 更大的缩放1.3倍 */
                filter: blur(25px) brightness(1.3) saturate(1.1);  /* 减少模糊但增加亮度和饱和度 */
            }
            33% {                                                 /* 动画进行到33%时 */
                transform: scale(1.4) rotate(2deg);              /* 最大缩放1.4倍，旋转2度 */
                filter: blur(28px) brightness(1.4) saturate(1.2);  /* 增加所有滤镜效果 */
            }
            66% {                                                 /* 动画进行到66%时 */
                transform: scale(1.35) rotate(-2deg);            /* 缩放1.35倍，反向旋转2度 */
                filter: blur(27px) brightness(1.35) saturate(1.15);  /* 中等滤镜强度 */
            }
            100% {                                                /* 动画结束 */
                transform: scale(1.3) rotate(0deg);              /* 回到起始状态 */
                filter: blur(25px) brightness(1.3) saturate(1.1);  /* 回到起始滤镜 */
            }
        }

        /* 左侧右边缘渐变遮罩 - 用于与中间区域平滑融合 */
        .left-blur-bg::after {
            content: '';                                          /* 伪元素必须有content属性 */
            position: absolute;                                   /* 绝对定位 */
            top: 0;                                               /* 从顶部开始 */
            right: 0;                                             /* 贴靠右边缘 */
            width: 30%;                                           /* 宽度占父容器的30% */
            height: 100%;                                         /* 高度100% */
            background: linear-gradient(to right,                 /* 从左到右的线性渐变 */
            transparent 0%,                                       /* 0%位置完全透明 */
            rgba(225, 245, 254, 0.3) 40%,                        /* 40%位置30%不透明度 */
            rgba(225, 245, 254, 0.7) 70%,                        /* 70%位置70%不透明度 */
            rgba(225, 245, 254, 1) 100%);                        /* 100%位置完全不透明 */
            pointer-events: none;                                 /* 不响应鼠标事件，让鼠标事件穿透 */
        }

        /* 右侧模糊背景层 - 使用夏日图片 */
        .right-blur-bg {
            position: fixed;              /* 固定定位，不随页面滚动 */
            top: 0;                       /* 距离顶部0像素 */
            right: 0;                     /* 贴靠右侧 */
            width: 50%;                   /* 宽度占屏幕的50% */
            height: 100%;                 /* 高度占满整个视口 */
            z-index: -3;                  /* 层级为-3，与左侧背景同层 */
            overflow: hidden;             /* 隐藏超出容器的内容 */
            opacity: 1 !important;        /* 强制显示，避免被其他样式覆盖 */
        }

        /* 右侧背景的伪元素 - 创建实际的模糊背景图片 */
        .right-blur-bg::before {
            content: '';                                          /* 伪元素必须有content属性 */
            position: absolute;                                   /* 绝对定位相对于父容器 */
            top: -10%;                                            /* 向上扩展10%，防止边缘露出 */
            left: -10%;                                           /* 向左扩展10%，防止边缘露出 */
            width: 120%;                                          /* 宽度120%，超出父容器 */
            height: 120%;                                         /* 高度120%，超出父容器 */
            background-image: url('./backgroundRight4.png');     /* 设置夏日背景图片 */
            background-size: cover;                               /* 背景图片覆盖整个区域 */
            background-position: center;                          /* 背景图片居中显示 */
            filter: blur(30px) brightness(0.6) saturate(0.8);    /* 模糊30px，亮度0.6（较暗），饱和度0.8 */
            transform: scale(1.2);                                /* 初始缩放1.2倍 */
            animation: rightBgDrift 25s ease-in-out infinite;    /* 应用动画：25秒周期，缓入缓出，无限循环 */
            will-change: transform, filter, background-position;  /* 优化性能：提前告知浏览器这些属性会变化 */
            transition: animation-duration 0.3s ease-in-out;      /* 动画持续时间变化时的过渡效果0.3秒 */
        }

        /* 右侧背景动画：飘逸移动和滤镜变化 - 更复杂的5个关键帧 */
        @keyframes rightBgDrift {
            0% {                                                  /* 动画起始状态 */
                transform: scale(1.2) translateX(0px) translateY(0px);  /* 缩放1.2倍，无位移 */
                filter: blur(30px) brightness(0.6) saturate(0.8);  /* 初始滤镜：模糊30px */
                background-position: center;                      /* 背景位置居中 */
            }
            20% {                                                 /* 动画进行到20%时 */
                transform: scale(1.15) translateX(-15px) translateY(10px);  /* 缩小到1.15倍，向左15px，向下10px */
                filter: blur(28px) brightness(0.65) saturate(0.9);  /* 减少模糊，增加亮度和饱和度 */
                background-position: 45% 45%;                     /* 背景位置偏移到左上 */
            }
            40% {                                                 /* 动画进行到40%时 */
                transform: scale(1.25) translateX(10px) translateY(-8px);  /* 放大到1.25倍，向右10px，向上8px */
                filter: blur(35px) brightness(0.7) saturate(1.0);  /* 最大模糊，最高亮度和饱和度 */
                background-position: 55% 40%;                     /* 背景位置偏移到右上 */
            }
            60% {                                                 /* 动画进行到60%时 */
                transform: scale(1.18) translateX(-8px) translateY(15px);  /* 缩放1.18倍，向左8px，向下15px */
                filter: blur(33px) brightness(0.55) saturate(0.85);  /* 中等模糊，最低亮度 */
                background-position: 40% 60%;                     /* 背景位置偏移到左下 */
            }
            80% {                                                 /* 动画进行到80%时 */
                transform: scale(1.22) translateX(12px) translateY(-5px);  /* 缩放1.22倍，向右12px，向上5px */
                filter: blur(31px) brightness(0.68) saturate(0.95);  /* 中等滤镜效果 */
                background-position: 60% 35%;                     /* 背景位置偏移到右上 */
            }
            100% {                                                /* 动画结束状态（回到起始） */
                transform: scale(1.2) translateX(0px) translateY(0px);  /* 恢复到初始位置和缩放 */
                filter: blur(30px) brightness(0.6) saturate(0.8);  /* 恢复到初始滤镜 */
                background-position: center;                      /* 恢复到居中位置 */
            }
        }

        /* 右侧背景悬停加强动画 - 鼠标悬停时触发更快速的动画 */
        .right-blur-bg:hover::before {
            animation: rightBgDriftIntense 10s ease-in-out infinite;  /* 悬停时切换到10秒周期的加强动画 */
        }

        /* 右侧背景加强动画关键帧 - 更大的移动幅度和更强的视觉效果 */
        @keyframes rightBgDriftIntense {
            0% {                                                  /* 动画起始 */
                transform: scale(1.3) translateX(0px) translateY(0px);  /* 更大的缩放1.3倍 */
                filter: blur(20px) brightness(0.8) saturate(1.2);  /* 减少模糊，大幅增加亮度和饱和度 */
                background-position: center;                      /* 背景居中 */
            }
            25% {                                                 /* 动画进行到25%时 */
                transform: scale(1.25) translateX(-25px) translateY(20px);  /* 缩小到1.25倍，向左25px，向下20px */
                filter: blur(18px) brightness(0.85) saturate(1.3);  /* 更清晰更明亮 */
                background-position: 35% 35%;                     /* 背景位置左上 */
            }
            50% {                                                 /* 动画进行到50%时（中点） */
                transform: scale(1.35) translateX(20px) translateY(-15px);  /* 最大缩放1.35倍，向右20px，向上15px */
                filter: blur(25px) brightness(0.9) saturate(1.4);  /* 最高亮度和饱和度 */
                background-position: 65% 30%;                     /* 背景位置右上 */
            }
            75% {                                                 /* 动画进行到75%时 */
                transform: scale(1.28) translateX(-18px) translateY(25px);  /* 缩放1.28倍，向左18px，向下25px */
                filter: blur(22px) brightness(0.75) saturate(1.25);  /* 中等亮度和饱和度 */
                background-position: 30% 70%;                     /* 背景位置左下 */
            }
            100% {                                                /* 动画结束 */
                transform: scale(1.3) translateX(0px) translateY(0px);  /* 回到起始状态 */
                filter: blur(20px) brightness(0.8) saturate(1.2);  /* 回到起始滤镜 */
                background-position: center;                      /* 回到居中位置 */
            }
        }

        /* 右侧左边缘渐变遮罩 - 用于与中间区域平滑融合 */
        .right-blur-bg::after {
            content: '';                                          /* 伪元素必须有content属性 */
            position: absolute;                                   /* 绝对定位 */
            top: 0;                                               /* 从顶部开始 */
            left: 0;                                              /* 贴靠左边缘 */
            width: 30%;                                           /* 宽度占父容器的30% */
            height: 100%;                                         /* 高度100% */
            background: linear-gradient(to left,                  /* 从右到左的线性渐变 */
            transparent 0%,                                       /* 0%位置完全透明 */
            rgba(225, 245, 254, 0.3) 40%,                        /* 40%位置30%不透明度 */
            rgba(225, 245, 254, 0.7) 70%,                        /* 70%位置70%不透明度 */
            rgba(225, 245, 254, 1) 100%);                        /* 100%位置完全不透明 */
            pointer-events: none;                                 /* 不响应鼠标事件，让鼠标事件穿透 */
        }

        /* 渐变遮罩层 - 让中间区域更亮，增强左右背景的融合效果 */
        .gradient-overlay {
            position: fixed;              /* 固定定位 */
            top: 0;                       /* 距离顶部0像素 */
            left: 0;                      /* 距离左侧0像素 */
            width: 100%;                  /* 宽度100% */
            height: 100%;                 /* 高度100% */
            z-index: -2;                  /* 层级为-2，位于背景层之上 */
            background: radial-gradient(ellipse 60% 100% at center,  /* 椭圆形径向渐变，宽60%高100%，从中心发散 */
            rgba(225, 245, 254, 0.6) 0%,                             /* 中心60%不透明度 */
            rgba(225, 245, 254, 0.4) 40%,                            /* 40%位置40%不透明度 */
            rgba(225, 245, 254, 0.2) 70%,                            /* 70%位置20%不透明度 */
            transparent 100%);                                        /* 边缘完全透明 */
            pointer-events: none;         /* 不响应鼠标事件 */
        }

        /* 噪点纹理效果 - 使用SVG生成细腻的噪点纹理，增加质感 */
        body::after {
            content: '';                  /* 伪元素必须有content属性 */
            position: fixed;              /* 固定定位 */
            top: 0;                       /* 距离顶部0像素 */
            left: 0;                      /* 距离左侧0像素 */
            width: 100%;                  /* 宽度100% */
            height: 100%;                 /* 高度100% */
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='3.5' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.03'/%3E%3C/svg%3E");  /* 内联SVG噪点图案：基础频率3.5，3个八度，不透明度0.03 */
            pointer-events: none;         /* 不响应鼠标事件 */
            z-index: -1;                  /* 层级为-1，位于最上层背景 */
            mix-blend-mode: overlay;      /* 混合模式：叠加，与下层内容混合 */
        }

        /* 右侧前景图片容器 - 正常显示夏日图片，支持3D视差效果 */
        #background {
            position: fixed;              /* 固定定位 */
            top: 0;                       /* 距离顶部0像素 */
            left: 400px;                  /* 从左侧400px开始（为文字留出空间） */
            width: 100%;                  /* 宽度100% */
            height: 100%;                 /* 高度100% */
            z-index: 1;                   /* 层级为1，位于背景之上 */
            display: flex;                /* 使用Flexbox布局 */
            align-items: center;          /* 垂直居中对齐 */
            justify-content: flex-start;  /* 水平靠左对齐 */
            overflow: visible;            /* 显示超出容器的内容 */
            opacity: 0;                   /* 初始透明，等待渐入 */
            transform: translateX(30px) scale(0.95);  /* 初始向右偏移30px并缩小5% */
            transition: opacity 1.2s, transform 1.2s;  /* 延迟0.8秒后开始2秒渐入动画 */
        }

        /* 右侧前景图片容器加载完成后的样式 */
        #background.foreground-loaded {
            opacity: 1;                   /* 完全不透明 */
            transform: translateX(0) scale(1);  /* 回到正常位置和大小 */
        }

        /* 右侧前景图片样式 - 支持鼠标视差和滤镜效果 */
        #background img {
            width: auto;                  /* 宽度自动 */
            height: auto;                 /* 高度自动 */
            max-width: 100%;              /* 最大宽度100%（不超出容器） */
            max-height: 100%;             /* 最大高度100%（不超出容器） */
            object-fit: contain;          /* 保持图片比例，完整显示在容器内 */
            object-position: center;      /* 图片在容器内居中 */
            filter: contrast(1.02) brightness(1.03) drop-shadow(0 0 20px rgba(255, 255, 255, 0.6)) drop-shadow(0 0 40px rgba(135, 206, 250, 0.4));  /* 默认滤镜：对比度1.02，亮度1.03，白色和蓝色边缘光 */
            transform-style: preserve-3d; /* 保持3D变换样式 */
            transition: transform 0.2s ease-out, filter 0.3s ease-out, box-shadow 0.3s ease-out;  /* 变换过渡0.2秒，滤镜过渡0.3秒，阴影过渡0.3秒 */
            will-change: transform, filter;  /* 优化性能：提前告知浏览器这些属性会变化 */
            position: relative;           /* 相对定位 */
        }

        /* 右侧前景图片深度层次效果 - 定义CSS变量控制阴影强度 */
        #background {
            --shadow-opacity: 0.6;        /* CSS变量：默认阴影不透明度为0.6 */
        }
        
        /* 右侧前景图片的背景阴影层 - 创建3D深度效果 */
        #background::before {
            content: '';                  /* 伪元素必须有content属性 */
            position: absolute;           /* 绝对定位 */
            top: -20px;                   /* 向上扩展20px */
            left: -20px;                  /* 向左扩展20px */
            right: -20px;                 /* 向右扩展20px */
            bottom: -20px;                /* 向下扩展20px */
            background: linear-gradient(135deg,   /* 135度角线性渐变（从左上到右下） */
                rgba(0, 0, 0, 0.1) 0%,           /* 左上角10%黑色阴影 */
                transparent 30%,                  /* 30%位置完全透明 */
                transparent 70%,                  /* 70%位置完全透明 */
                rgba(0, 0, 0, 0.08) 100%);       /* 右下角8%黑色阴影 */
            border-radius: 20px;          /* 圆角20px */
            filter: blur(15px);           /* 模糊15px */
            z-index: -1;                  /* 层级-1，位于图片下方 */
            transition: all 0.3s ease-out;  /* 所有属性过渡0.3秒 */
            opacity: var(--shadow-opacity, 0.6);  /* 使用CSS变量控制不透明度，默认0.6 */
            transform: translateZ(-10px); /* Z轴向后移动10px（3D效果） */
        }



        /* 左侧前景图片容器 - 正常显示雨天图片，支持3D视差效果 */
        #background2 {
            position: fixed;              /* 固定定位 */
            top: 0;                       /* 距离顶部0像素 */
            left: -400px;                 /* 向左偏移400px（部分隐藏在屏幕外） */
            width: 100%;                  /* 宽度100% */
            height: 100%;                 /* 高度100% */
            z-index: 1;                   /* 层级为1，与右侧图片同层 */
            display: flex;                /* 使用Flexbox布局 */
            align-items: center;          /* 垂直居中对齐 */
            justify-content: flex-end;    /* 水平靠右对齐 */
            overflow: visible;            /* 显示超出容器的内容 */
            opacity: 0;                   /* 初始透明，等待渐入 */
            transform: translateX(-30px) scale(0.95);  /* 初始向左偏移30px并缩小5% */
            transition: opacity 1.2s , transform 1.2s;  /* 延迟1.2秒后开始2秒渐入动画（比右侧稍晚） */
        }

        /* 左侧前景图片容器加载完成后的样式 */
        #background2.foreground-loaded {
            opacity: 1;                   /* 完全不透明 */
            transform: translateX(0) scale(1);  /* 回到正常位置和大小 */
        }

        /* 左侧前景图片样式 - 支持鼠标视差和滤镜效果 */
        #background2 img {
            width: auto;                  /* 宽度自动 */
            height: auto;                 /* 高度自动 */
            max-width: 100%;              /* 最大宽度100%（不超出容器） */
            max-height: 100%;             /* 最大高度100%（不超出容器） */
            object-fit: contain;          /* 保持图片比例，完整显示在容器内 */
            object-position: center;      /* 图片在容器内居中 */
            filter: contrast(1.02) brightness(1.03);  /* 默认滤镜：对比度1.02，亮度1.03 */
            transform-style: preserve-3d; /* 保持3D变换样式 */
            transition: transform 0.2s ease-out, filter 0.3s ease-out, box-shadow 0.3s ease-out;  /* 变换过渡0.2秒，滤镜过渡0.3秒，阴影过渡0.3秒 */
            will-change: transform, filter;  /* 优化性能：提前告知浏览器这些属性会变化 */
            position: relative;           /* 相对定位 */
        }

        /* 左侧前景图片深度层次效果 - 定义CSS变量控制阴影强度 */
        #background2 {
            --shadow-opacity: 0.7;        /* CSS变量：默认阴影不透明度为0.7（比右侧稍强） */
        }

        /* 左侧前景图片的背景阴影层 - 创建3D深度效果（比右侧更强） */
        #background2::before {
            content: '';                  /* 伪元素必须有content属性 */
            position: absolute;           /* 绝对定位 */
            top: -25px;                   /* 向上扩展25px（比右侧多5px） */
            left: -25px;                  /* 向左扩展25px */
            right: -25px;                 /* 向右扩展25px */
            bottom: -25px;                /* 向下扩展25px */
            background: linear-gradient(225deg,   /* 225度角线性渐变（从右上到左下） */
                rgba(0, 0, 0, 0.02) 0%,          /* 右上角12%黑色阴影 */
                transparent 25%,                  /* 25%位置完全透明 */
                transparent 75%,                  /* 75%位置完全透明 */
                rgba(0, 0, 0, 0.09) 100%);       /* 左下角9%黑色阴影 */
            border-radius: 25px;          /* 圆角25px */
            filter: blur(18px);           /* 模糊18px（比右侧多3px） */
            z-index: -1;                  /* 层级-1，位于图片下方 */
            transition: all 0.3s ease-out;  /* 所有属性过渡0.3秒 */
            opacity: var(--shadow-opacity, 0.7);  /* 使用CSS变量控制不透明度，默认0.7 */
            transform: translateZ(-15px); /* Z轴向后移动15px（比右侧多5px，3D效果更强） */
        }



        /* 主容器 - 包含文字Canvas的容器 */
        .container {
            position: relative;           /* 相对定位 */
            width: 100%;                  /* 宽度100% */
            height: 100vh;                /* 高度为视口高度（100%视口高度） */
            display: flex;                /* 使用Flexbox布局 */
            align-items: center;          /* 垂直居中对齐 */
            padding-left: 80px;           /* 左侧内边距80px */
            z-index: 10;                  /* 层级为10，位于所有背景之上 */
            opacity: 0;                   /* 初始透明，等待背景加载完成后渐入 */
            transform: translateY(30px) scale(0.98);  /* 初始向下偏移30px并轻微缩小 */
            transition: opacity 1.8s ease-out 0.5s, transform 1.8s ease-out 0.5s; /* 延迟0.5秒后开始1.8秒渐入动画 */
        }

        /* 内容加载完成后的样式 */
        .container.content-loaded {
            opacity: 1;                   /* 完全不透明 */
            transform: translateY(0) scale(1);  /* 回到正常位置和大小 */
        }

        /* Canvas容器 - 包裹文字Canvas */
        .text-canvas-container {
            position: relative;           /* 相对定位 */
        }

        /* Canvas元素样式 */
        canvas {
            display: block;               /* 块级元素显示，避免底部留白 */
        }

        /* 装饰线条样式（代码中绘制，这里定义备用样式） */
        .line {
            width: 120px;                 /* 宽度120px */
            height: 1px;                  /* 高度1px */
            background: rgba(255, 255, 255, 0.4);  /* 40%不透明度的白色 */
            margin: 20px 0;               /* 上下外边距20px */
        }

        /* 动画性能优化 - 启用硬件加速 */
        .left-blur-bg, .right-blur-bg {
            transform: translateZ(0);     /* 强制启用GPU加速 */
            backface-visibility: hidden;  /* 隐藏元素背面，优化动画性能 */
            perspective: 1000px;          /* 设置3D透视距离为1000px */
        }

        /* 预设动画变量 - 定义全局动画速度 */
        :root {
            --bg-animation-speed: 1;      /* 背景动画速度倍数（基准值） */
            --hover-animation-speed: 1.5; /* 悬停动画速度倍数（1.5倍速） */
        }

        /* 3D透视容器 - 为前景图片设置3D透视 */
        #background, #background2 {
            perspective: 1500px;          /* 3D透视距离1500px（数值越小，3D效果越强） */
            perspective-origin: center center;  /* 透视原点在中心 */
            transform-style: preserve-3d; /* 保持子元素的3D变换 */
        }

        /* 右侧前景图片悬停增强效果 - 增强阴影和3D效果 */
        #background:hover::before {
            transform: translateZ(-5px) scale(1.05);  /* 阴影向后移动5px并放大1.05倍 */
            opacity: calc(var(--shadow-opacity) * 1.3);  /* 阴影不透明度增加到1.3倍 */
            filter: blur(20px);           /* 模糊增加到20px */
        }

        /* 左侧前景图片悬停增强效果 - 增强阴影和3D效果（比右侧更强） */
        #background2:hover::before {
            transform: translateZ(-8px) scale(1.08);  /* 阴影向后移动8px并放大1.08倍 */
            opacity: calc(var(--shadow-opacity) * 1.4);  /* 阴影不透明度增加到1.4倍 */
            filter: blur(22px);           /* 模糊增加到22px */
        }

        /* 前景图片悬停时的3D浮起效果 */
        #background:hover img,
        #background2:hover img {
            transform: translateZ(30px) !important;  /* 图片向前浮起30px（重要规则） */
        }

        /* 响应式设计 - 适配平板设备（最大宽度768px） */
        @media (max-width: 768px) {
            .container {
                padding-left: 40px;       /* 减少左侧内边距到40px */
            }
            
            /* 在小屏幕上减少动画强度，提升性能 */
            .left-blur-bg::before,
            .right-blur-bg::before {
                animation-duration: 30s;  /* 延长动画时间到30秒（减慢动画） */
            }
            
            .left-blur-bg:hover::before {
                animation-duration: 12s;  /* 悬停动画延长到12秒 */
            }
            
            .right-blur-bg:hover::before {
                animation-duration: 15s;  /* 悬停动画延长到15秒 */
            }

            /* 在小屏幕上减少视差效果，提升性能 */
            #background, #background2 {
                perspective: 800px;       /* 减少透视距离到800px（减弱3D效果） */
            }
            
            #background::before,
            #background2::before {
                filter: blur(10px);       /* 减少阴影模糊到10px */
            }
        }

        /* 响应式设计 - 适配手机设备（最大宽度480px） */
        @media (max-width: 480px) {
            /* 在超小屏幕上进一步优化阴影效果，减少性能开销 */
            #background::before,
            #background2::before {
                top: -10px;               /* 减少阴影扩展到10px */
                left: -10px;              /* 减少阴影扩展到10px */
                right: -10px;             /* 减少阴影扩展到10px */
                bottom: -10px;            /* 减少阴影扩展到10px */
                filter: blur(8px);        /* 进一步减少模糊到8px */
            }
        }
        
        /* 减少动画偏好用户的优化 - 遵循用户的无障碍设置 */
        @media (prefers-reduced-motion: reduce) {
            /* 禁用所有背景动画 */
            .left-blur-bg::before,
            .right-blur-bg::before,
            .left-blur-bg:hover::before,
            .right-blur-bg:hover::before {
                animation: none;          /* 移除所有动画 */
            }

            /* 禁用前景图片的变换和过渡效果 */
            #background img,
            #background2 img {
                transform: none !important;   /* 移除所有变换 */
                transition: none !important;  /* 移除所有过渡效果 */
            }

            /* 禁用前景图片阴影的变换效果 */
            #background::before,
            #background2::before {
                transform: none !important;   /* 移除所有变换 */
            }
        }
    </style>
</head>
<body>
<!-- 左侧模糊背景层 -->
<div class="left-blur-bg"></div>

<!-- 右侧模糊背景层 -->
<div class="right-blur-bg"></div>

<!-- 渐变遮罩层 -->
<div class="gradient-overlay"></div>

<!-- 第二个背景图片 -->
<div id="background2">
    <img src="./backgroundRight4.png" alt="Background 2">
</div>

<!-- 背景图片 -->
<div id="background">
    <img src="./backgroundLeft.jpg" alt="Background">
</div>

<!-- 主容器 -->
<div class="container">
    <div class="text-canvas-container">
        <canvas id="textCanvas"></canvas>
    </div>
</div>

<script>
    // ========== Perlin Noise 类实现 - 用于生成平滑的随机噪声效果 ==========
    class PerlinNoise {
        constructor() {
            // 创建置换表数组，用于生成伪随机梯度
            this.p = new Array(512);           // 512个元素的数组（256的两倍，避免溢出）
            this.permutation = [];             // 0-255的随机排列

            // 生成0-255的随机排列
            for (let i = 0; i < 256; i++) {
                this.permutation[i] = Math.floor(Math.random() * 256);
            }

            // 将排列数组复制两次到p数组中，避免索引越界
            for (let i = 0; i < 512; i++) {
                this.p[i] = this.permutation[i & 255];  // i & 255 等价于 i % 256
            }
        }

        /**
         * 淡入淡出函数 - 用于平滑插值
         * @param {number} t - 输入值 (0-1)
         * @return {number} - 平滑后的值 (0-1)
         */
        fade(t) {
            // Ken Perlin的改进淡入淡出函数: 6t^5 - 15t^4 + 10t^3
            return t * t * t * (t * (t * 6 - 15) + 10);
        }

        /**
         * 线性插值函数
         * @param {number} t - 插值因子 (0-1)
         * @param {number} a - 起始值
         * @param {number} b - 结束值
         * @return {number} - 插值结果
         */
        lerp(t, a, b) {
            return a + t * (b - a);
        }

        /**
         * 梯度函数 - 计算梯度向量与距离向量的点积
         * @param {number} hash - 哈希值，用于选择梯度方向
         * @param {number} x - x方向的距离
         * @param {number} y - y方向的距离
         * @return {number} - 点积结果
         */
        grad(hash, x, y) {
            const h = hash & 15;              // 取哈希值的低4位 (0-15)
            const u = h < 8 ? x : y;          // 如果h<8使用x，否则使用y
            const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;  // 根据h值选择v
            // 根据h的位模式决定是否取反，计算点积
            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        }

        /**
         * 2D Perlin噪声主函数
         * @param {number} x - x坐标
         * @param {number} y - y坐标
         * @return {number} - 噪声值 (-1到1之间)
         */
        noise(x, y) {
            // 找到单位网格的坐标
            const X = Math.floor(x) & 255;    // x的整数部分，限制在0-255
            const Y = Math.floor(y) & 255;    // y的整数部分，限制在0-255

            // 找到网格内的相对位置
            x -= Math.floor(x);               // x的小数部分 (0-1)
            y -= Math.floor(y);               // y的小数部分 (0-1)

            // 计算淡入淡出曲线
            const u = this.fade(x);           // x的平滑值
            const v = this.fade(y);           // y的平滑值

            // 计算网格四个角的哈希值
            const a = this.p[X] + Y;          // 左下角
            const aa = this.p[a];             // 左下角的哈希值
            const ab = this.p[a + 1];         // 左上角的哈希值
            const b = this.p[X + 1] + Y;      // 右下角
            const ba = this.p[b];             // 右下角的哈希值
            const bb = this.p[b + 1];         // 右上角的哈希值

            // 对四个角的梯度进行双线性插值
            return this.lerp(v,
                this.lerp(u, this.grad(this.p[aa], x, y), this.grad(this.p[ba], x - 1, y)),        // 下边插值
                this.lerp(u, this.grad(this.p[ab], x, y - 1), this.grad(this.p[bb], x - 1, y - 1))  // 上边插值
            );
        }
    }

    // ========== Canvas 初始化 ==========
    const canvas = document.getElementById('textCanvas');  // 获取Canvas元素
    const ctx = canvas.getContext('2d');                   // 获取2D渲染上下文
    const perlin = new PerlinNoise();                       // 创建Perlin噪声生成器实例
    let time = 0;                                           // 时间变量，用于动画（随时间递增）

    // 设置Canvas画布尺寸
    canvas.width = 800;                                     // 画布宽度800像素
    canvas.height = 600;                                    // 画布高度600像素

    // ========== 文字内容和样式配置数组 ==========
    // 每个对象定义一行文字的所有属性
    const texts = [
        { 
            text: 'SILENT HAZE',                           // 文字内容：标题
            x: 0,                                           // x坐标位置
            y: 50,                                          // y坐标位置
            size: 16,                                       // 字体大小（像素）
            weight: '300',                                  // 字重：300（细体）
            spacing: 5,                                     // 字间距（像素）
            noiseScale: 0.05                                // 噪声缩放比例（控制噪声"瓦片"大小）
        },
        { 
            text: 'SUMMER',                                 // 文字内容：主标题1
            x: 0, 
            y: 180, 
            size: 96,                                       // 大字号：96像素
            weight: '700',                                  // 字重：700（粗体）
            spacing: 0, 
            noiseScale: 0.02                                // 较小的噪声比例（更细腻的效果）
        },
        { 
            text: 'BREEZE',                                 // 文字内容：主标题2
            x: 0, 
            y: 280, 
            size: 96, 
            weight: '700', 
            spacing: 0, 
            noiseScale: 0.02 
        },
        { 
            text: '25時、ナイトコードで。× 初音ミク',  // 文字内容：日文副标题
            x: 0, 
            y: 360, 
            size: 15,                                       // 小字号：15像素
            weight: '300', 
            spacing: 2, 
            noiseScale: 0.08                                // 较大的噪声比例（更明显的波动效果）
        }
    ];

    // ========== 绘制带噪声效果的文字函数 ==========
    /**
     * 在Canvas上绘制带有Perlin噪声效果的文字
     * 噪声效果使文字产生动态的"消散"或"波动"视觉效果
     */
    function drawTextWithNoise() {
        // 清空整个画布，准备重新绘制
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 遍历所有文字对象，逐个绘制
        texts.forEach((textObj, index) => {
            // 设置主画布的字体样式（用于测量文字尺寸）
            ctx.font = `${textObj.weight} ${textObj.size}px Arial`;  // 设置字重和大小
            ctx.textBaseline = 'top';                                 // 文字基线对齐到顶部

            // 测量文字的实际渲染宽度
            const metrics = ctx.measureText(textObj.text);
            const textWidth = metrics.width;                          // 文字宽度（像素）
            const textHeight = textObj.size;                          // 文字高度（近似等于字号）

            // 创建临时画布，用于处理单个文字的像素数据
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = textWidth + 20;                        // 临时画布宽度（留出边距）
            tempCanvas.height = textHeight + 20;                      // 临时画布高度（留出边距）

            // 在临时画布上绘制白色文字
            tempCtx.font = ctx.font;                                  // 复制字体样式
            tempCtx.fillStyle = 'white';                              // 设置填充颜色为白色
            tempCtx.textBaseline = 'top';                             // 文字基线对齐到顶部
            tempCtx.fillText(textObj.text, 10, 10);                   // 绘制文字（偏移10px留边距）

            // 获取临时画布上的像素数据（RGBA格式）
            const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            const data = imageData.data;                              // 像素数组：[R, G, B, A, R, G, B, A, ...]

            // 遍历临时画布的每个像素，应用噪声效果
            for (let y = 0; y < tempCanvas.height; y++) {
                for (let x = 0; x < tempCanvas.width; x++) {
                    const index = (y * tempCanvas.width + x) * 4;    // 计算像素在数组中的索引（每个像素4个值）
                    const alpha = data[index + 3];                    // 获取当前像素的Alpha通道值

                    // 只处理不透明的像素（即文字区域）
                    if (alpha > 0) {
                        // 计算Perlin噪声值
                        // noiseScale控制噪声的"频率"：值越小，噪声变化越平滑
                        const noiseX = x * textObj.noiseScale;        // x坐标缩放
                        const noiseY = y * textObj.noiseScale;        // y坐标缩放
                        const noise = perlin.noise(noiseX + time, noiseY + time * 0.5);  // 获取噪声值（-1到1），加入时间参数使其动画化
                        const normalizedNoise = (noise + 1) / 2;      // 归一化噪声值到0-1范围

                        // 根据噪声调整像素的颜色和透明度
                        // const intensity = index < 2 ? 30 : 50;     // 这行代码未使用（可以删除）
                        data[index] = 255;                            // R通道：白色
                        data[index + 1] = 255;                        // G通道：白色
                        data[index + 2] = 255;                        // B通道：白色
                        // Alpha通道：基于噪声值调整透明度
                        // 公式说明：(1 - normalizedNoise*0.4)^2 * alpha
                        // - normalizedNoise*0.4: 噪声影响强度为40%
                        // - (1 - ...)^2: 平方函数，使过渡更柔和
                        // - * alpha: 保留原始透明度信息
                        data[index + 3] = Math.pow((1 - normalizedNoise * 0.4), 2) * alpha;
                    }
                }
            }

            // 将处理后的像素数据写回临时画布
            tempCtx.putImageData(imageData, 0, 0);
            // 将临时画布的内容绘制到主画布上
            ctx.drawImage(tempCanvas, textObj.x, textObj.y);

            // 绘制装饰线条（在第一个文字[index=0]和第三个文字[index=2]后）
            if (index === 0 || index === 2) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';          // 半透明白色
                ctx.fillRect(textObj.x, textObj.y + textObj.size + 20, 120, 1);  // 绘制120px宽，1px高的线条
            }
        });

        // 为所有文字添加统一的阴影效果（增加深度感）
        ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';                      // 阴影颜色：30%不透明度的黑色
        ctx.shadowBlur = 8;                                           // 阴影模糊半径：8像素
        ctx.shadowOffsetX = 0;                                        // 阴影水平偏移：0像素（正下方）
        ctx.shadowOffsetY = 4;                                        // 阴影垂直偏移：4像素（向下）
    }

    // ========== 前景图片视差和3D效果相关变量初始化 ==========
    const backgroundImg1 = document.querySelector('#background img');        // 右侧前景图片元素
    const backgroundImg2 = document.querySelector('#background2 img');       // 左侧前景图片元素
    const backgroundContainer1 = document.querySelector('#background');      // 右侧前景图片容器
    const backgroundContainer2 = document.querySelector('#background2');     // 左侧前景图片容器
    
    let mouseX = window.innerWidth / 2;                                      // 鼠标当前x坐标（初始化为屏幕中心）
    let mouseY = window.innerHeight / 2;                                     // 鼠标当前y坐标（初始化为屏幕中心）
    let targetX1 = 0;                                                        // 右侧图片目标x偏移量（归一化值，-1到1）
    let targetY1 = 0;                                                        // 右侧图片目标y偏移量（归一化值，-1到1）
    let targetX2 = 0;                                                        // 左侧图片目标x偏移量（归一化值，-1到1）
    let targetY2 = 0;                                                        // 左侧图片目标y偏移量（归一化值，-1到1）
    let isHoveringImg1 = false;                                              // 是否悬停在右侧图片上
    let isHoveringImg2 = false;                                              // 是否悬停在左侧图片上
    
    // ========== 检测鼠标是否在前景图片区域内的函数 ==========
    /**
     * 检测鼠标是否在指定的前景图片区域内
     * @param {number} mouseX - 鼠标x坐标
     * @param {number} mouseY - 鼠标y坐标
     * @param {HTMLElement} container - 图片容器元素
     * @param {HTMLElement} img - 图片元素
     * @return {boolean} - 是否在图片区域内
     */
    function isMouseOverImage(mouseX, mouseY, container, img) {
        if (!container || !img) return false;
        
        const containerRect = container.getBoundingClientRect();
        const imgRect = img.getBoundingClientRect();
        
        // 检测鼠标是否在图片的实际显示区域内
        return mouseX >= imgRect.left && 
               mouseX <= imgRect.right && 
               mouseY >= imgRect.top && 
               mouseY <= imgRect.bottom;
    }

    // ========== 鼠标移动事件监听器 - 实现按区域的视差效果 ==========
    /**
     * 监听鼠标移动，检测是否在前景图片区域内
     * 只对鼠标悬停的图片应用视差效果
     */
    document.addEventListener('mousemove', (e) => {
        mouseX = e.clientX;                                                  // 更新鼠标x坐标
        mouseY = e.clientY;                                                  // 更新鼠标y坐标
        
        // 检测鼠标是否悬停在各个前景图片上
        isHoveringImg1 = isMouseOverImage(mouseX, mouseY, backgroundContainer1, backgroundImg1);
        isHoveringImg2 = isMouseOverImage(mouseX, mouseY, backgroundContainer2, backgroundImg2);
        
        // 计算鼠标相对于屏幕中心的归一化偏移量（-1到1之间）
        const centerX = window.innerWidth / 2;                               // 屏幕中心x坐标
        const centerY = window.innerHeight / 2;                              // 屏幕中心y坐标
        const offsetX = (mouseX - centerX) / centerX;                        // x方向偏移量：-1（最左）到1（最右）
        const offsetY = (mouseY - centerY) / centerY;                        // y方向偏移量：-1（最上）到1（最下）
        
        // 只为悬停的图片更新目标位置，未悬停的图片目标位置逐渐回到0
        if (isHoveringImg1) {
            targetX1 = offsetX;
            targetY1 = offsetY;
        } else {
            // 平滑回到原始位置
            targetX1 *= 0.95;
            targetY1 *= 0.95;
        }
        
        if (isHoveringImg2) {
            targetX2 = offsetX;
            targetY2 = offsetY;
        } else {
            // 平滑回到原始位置
            targetX2 *= 0.95;
            targetY2 *= 0.95;
        }
    });
    
    // ========== 平滑视差动画更新函数 ==========
    /**
     * 根据鼠标位置更新前景图片的3D变换效果
     * 包括：位移、旋转、缩放、滤镜、阴影等
     * 每帧调用一次，实现平滑的视差效果
     * 现在只对悬停的图片应用变换效果
     */
    function updateParallax() {
        // ---------- 视差参数配置 ----------
        const parallaxStrength1 = 25;       // 右侧图片视差移动强度（像素）
        const parallaxStrength2 = 30;       // 左侧图片视差移动强度（像素，略强于右侧）
        const tiltStrength = 4;             // 3D倾斜旋转强度（度数）
        const scaleBase = 1.02;             // 基础缩放比例（1.02 = 放大2%）
        
        // ---------- 计算右侧图片的变换值 ----------
        const moveX1 = targetX1 * parallaxStrength1;                         // x方向移动距离（像素）：鼠标右移图片右移
        const moveY1 = targetY1 * parallaxStrength1 * 0.7;                   // y方向移动距离（像素）：系数0.7使垂直移动较弱
        const tiltX1 = targetY1 * tiltStrength;                              // 绕x轴旋转角度（度）：鼠标下移图片向后倾
        const tiltY1 = -targetX1 * tiltStrength;                             // 绕y轴旋转角度（度）：鼠标右移图片向左转（负值）
        const scale1 = scaleBase + Math.abs(targetX1 * 0.03) + Math.abs(targetY1 * 0.02);  // 动态缩放：鼠标远离中心时放大
        
        // ---------- 计算左侧图片的变换值 ----------
        const moveX2 = -targetX2 * parallaxStrength2;                        // x方向移动距离（像素）：与右侧相反（负值）
        const moveY2 = targetY2 * parallaxStrength2 * 0.8;                   // y方向移动距离（像素）：系数0.8
        const tiltX2 = -targetY2 * tiltStrength;                             // 绕x轴旋转角度（度）：与右侧相反
        const tiltY2 = targetX2 * tiltStrength;                              // 绕y轴旋转角度（度）：与右侧相反
        const scale2 = scaleBase + Math.abs(targetX2 * 0.025) + Math.abs(targetY2 * 0.025);  // 动态缩放：系数略小于右侧
        
        // 应用3D变换到右侧图片
        if (backgroundImg1) {
            backgroundImg1.style.transform =
                `perspective(1200px) ` +
                `translateX(${moveX1}px) translateY(${moveY1}px) ` +
                `rotateX(${tiltX1}deg) rotateY(${tiltY1}deg) ` +
                `scale(${scale1}) ` +
                `translateZ(20px)`;

            // 动态调整滤镜
            const filterBrightness = 1.03 + Math.abs(targetX1 * 0.05);
            const filterContrast = 1.02 + Math.abs(targetY1 * 0.08);
            const filterSaturate = 1 + Math.abs(targetX1 * 0.1);
            // 计算动态边缘光强度
            const glowIntensity = 0.6 + Math.abs(targetX1 * 0.2) + Math.abs(targetY1 * 0.2);
            const glowBlue = 0.4 + Math.abs(targetX1 * 0.15);
            backgroundImg1.style.filter =
                `contrast(${filterContrast}) brightness(${filterBrightness }) saturate(${filterSaturate}) drop-shadow(0 0 20px rgba(255, 255, 255, ${glowIntensity})) drop-shadow(0 0 70px rgba(102, 242, 255, ${glowBlue }))`;
        }
        
        // 应用3D变换到左侧图片
        if (backgroundImg2) {
            backgroundImg2.style.transform = 
                `perspective(1200px) ` +
                `translateX(${moveX2}px) translateY(${moveY2}px) ` +
                `rotateX(${tiltX2}deg) rotateY(${tiltY2}deg) ` +
                `scale(${scale2}) ` +
                `translateZ(15px)`;
                
            // 动态调整滤镜
            const filterBrightness = 1.03 + Math.abs(targetY2 * 0.06);
            const filterContrast = 1.02 + Math.abs(targetX2 * 0.07);
            const filterSaturate = 1 + Math.abs(targetY2 * 0.08);
            backgroundImg2.style.filter =
                `contrast(${filterContrast}) brightness(${filterBrightness}) saturate(${filterSaturate})`;
        }
        
        // 更新深度阴影
        if (backgroundContainer1) {
            const shadowIntensity1 = 0.6 + Math.abs(targetX1 * 0.2) + Math.abs(targetY1 * 0.15);
            backgroundContainer1.style.setProperty('--shadow-opacity', shadowIntensity1);
        }
        
        if (backgroundContainer2) {
            const shadowIntensity2 = 0.7 + Math.abs(targetX2 * 0.25) + Math.abs(targetY2 * 0.2);
            backgroundContainer2.style.setProperty('--shadow-opacity', shadowIntensity2);
        }
    }

    // ========== 鼠标悬停交互 - Canvas文字区域 ==========
    let isHovering = false;                                                   // 标记是否悬停在标题上
    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();                         // 获取Canvas相对于视口的位置
        const x = e.clientX - rect.left;                                     // 计算鼠标相对于Canvas的x坐标
        const y = e.clientY - rect.top;                                      // 计算鼠标相对于Canvas的y坐标

        // 检测是否悬停在主标题"SUMMER"或"BREEZE"上（y: 180-300, x: 0-600）
        isHovering = (y > 180 && y < 300 && x < 600);
        canvas.style.cursor = isHovering ? 'pointer' : 'default';            // 悬停时显示手型光标，否则默认光标
    });

    // ========== 滚动视差效果 ==========
    let scrollY = 0;                                                          // 当前滚动位置
    let ticking = false;                                                      // 防抖标志，避免频繁触发
    
    /**
     * 更新滚动视差效果
     * 根据页面滚动位置调整前景图片的垂直位置
     */
    function updateScrollParallax() {
        const scrollFactor1 = scrollY * 0.3;                                 // 右侧图片滚动系数：0.3（向下移动）
        const scrollFactor2 = scrollY * 0.4;                                 // 左侧图片滚动系数：0.4（向上移动，注意负号）
        
        if (backgroundContainer1) {
            backgroundContainer1.style.transform = `translateY(${scrollFactor1}px)`;  // 右侧图片随滚动向下移动
        }
        
        if (backgroundContainer2) {
            backgroundContainer2.style.transform = `translateY(${-scrollFactor2}px)`; // 左侧图片随滚动向上移动（创建对比效果）
        }
    }
    
    // 监听滚动事件，使用requestAnimationFrame优化性能
    window.addEventListener('scroll', () => {
        scrollY = window.pageYOffset;                                        // 更新滚动位置（兼容旧浏览器）
        
        if (!ticking) {                                                      // 如果没有待处理的动画帧
            requestAnimationFrame(() => {                                    // 在下一帧更新视差效果
                updateScrollParallax();
                ticking = false;                                             // 重置标志
            });
            ticking = true;                                                  // 设置标志，防止重复调用
        }
    });

    // ========== 主动画循环 ==========
    /**
     * 主动画循环函数
     * 每帧更新：文字噪声动画 + 视差效果
     * 使用requestAnimationFrame实现流畅的60fps动画
     */
    function animate() {
        time += 0.005;                                                        // 递增时间变量，控制噪声动画速度（0.005 = 缓慢变化）
        drawTextWithNoise();                                                  // 重绘带噪声效果的文字
        updateParallax();                                                     // 更新前景图片的视差效果
        requestAnimationFrame(animate);                                       // 请求下一帧动画（递归调用）
    }

    // 启动动画循环
    animate();

    // ========== 窗口大小调整事件监听器 ==========
    let resizeTimeout;                                                        // 防抖定时器
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);                                         // 清除之前的定时器
        resizeTimeout = setTimeout(() => {                                   // 延迟150毫秒执行，避免频繁触发
            // 重新计算屏幕中心点，重置鼠标位置
            mouseX = window.innerWidth / 2;                                  // 重置为新的屏幕中心x
            mouseY = window.innerHeight / 2;                                 // 重置为新的屏幕中心y
            targetX1 = 0;                                                    // 重置右侧图片目标x偏移量
            targetY1 = 0;                                                    // 重置右侧图片目标y偏移量
            targetX2 = 0;                                                    // 重置左侧图片目标x偏移量
            targetY2 = 0;                                                    // 重置左侧图片目标y偏移量
            isHoveringImg1 = false;                                          // 重置右侧图片悬停状态
            isHoveringImg2 = false;                                          // 重置左侧图片悬停状态
            
            // 重置前景图片的变换和滤镜效果
            if (backgroundImg1) {
                backgroundImg1.style.transform = '';                         // 清除右侧图片的变换
                // 重置右侧图片的滤镜：对比度1.02，亮度1.03，添加白色和蓝色投影
                backgroundImg1.style.filter = 'contrast(1.02) brightness(1.03) drop-shadow(0 0 20px rgba(255, 255, 255, 0.6)) drop-shadow(0 0 40px rgba(135, 206, 250, 0.4))';
            }
            if (backgroundImg2) {
                backgroundImg2.style.transform = '';                         // 清除左侧图片的变换
                backgroundImg2.style.filter = '';                            // 清除左侧图片的滤镜
            }
            
            // 可以在这里添加其他响应式逻辑（如重新计算Canvas尺寸等）
        }, 150);                                                             // 延迟150毫秒执行
    });
    
    // ========== 页面可见性API优化 ==========
    /**
     * 当用户切换到其他标签页时暂停动画，节省资源
     * 当用户回到此标签页时恢复动画
     */
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            // 页面隐藏时暂停动画（注意：cancelAnimationFrame需要动画ID，这里实际无法暂停）
            // 正确的做法是在animate函数中检查document.hidden状态
            cancelAnimationFrame(animate);                                   // 尝试取消动画帧（此处逻辑有误，但保留原代码）
        } else {
            // 页面恢复显示时重新启动动画循环
            animate();
        }
    });
    
    // ========== 页面加载完成事件监听器 ==========
    /**
     * 等待所有资源（特别是图片）加载完成后初始化视差效果
     * 确保图片已经渲染，避免计算错误
     */
    window.addEventListener('load', () => {
        updateParallax();                                                     // 初始化视差效果（确保正确的初始状态）
        
        // 分阶段显示各个元素
        setTimeout(() => {
            // 首先显示内容（文字）
            const container = document.querySelector('.container');
            if (container) {
                container.classList.add('content-loaded');                   // 添加content-loaded类，触发内容渐入动画
            }
        }, 300);                                                             // 延迟300毫秒，确保背景已渲染
        
        setTimeout(() => {
            // 然后显示右侧前景图片
            const background1 = document.querySelector('#background');
            if (background1) {
                background1.classList.add('foreground-loaded');              // 添加foreground-loaded类，触发前景图片渐入动画
            }
        }, 600);                                                             // 延迟600毫秒
        
        setTimeout(() => {
            // 最后显示左侧前景图片
            const background2 = document.querySelector('#background2');
            if (background2) {
                background2.classList.add('foreground-loaded');              // 添加foreground-loaded类，触发前景图片渐入动画
            }
        }, 1000);                                                            // 延迟1000毫秒
    });

    // ========== 页面DOM加载完成时立即显示背景 ==========
    /**
     * 当DOM加载完成时（不等待图片等资源），立即显示背景
     * 这样用户可以立即看到背景，避免白屏
     */
    document.addEventListener('DOMContentLoaded', () => {
        // 背景立即显示，无需等待
        document.body.style.opacity = '1';
        
        // 检查图片加载状态，如果已缓存则提前开始分阶段显示
        const images = document.querySelectorAll('img');
        let loadedImages = 0;
        const totalImages = images.length;
        
        if (totalImages === 0) {
            // 没有图片时，使用较快的时间节点
            setTimeout(() => {
                const container = document.querySelector('.container');
                if (container) {
                    container.classList.add('content-loaded');
                }
            }, 200);
            
            setTimeout(() => {
                const background1 = document.querySelector('#background');
                const background2 = document.querySelector('#background2');
                if (background1) background1.classList.add('foreground-loaded');
                if (background2) background2.classList.add('foreground-loaded');
            }, 400);
        } else {
            // 检查图片加载状态
            images.forEach(img => {
                if (img.complete) {
                    loadedImages++;
                } else {
                    img.addEventListener('load', () => {
                        loadedImages++;
                        // 当图片加载完成时，不在这里触发显示，让window.load事件处理
                    });
                }
            });
            
            // 如果所有图片都已加载（缓存），使用较快的时间节点
            if (loadedImages === totalImages) {
                setTimeout(() => {
                    const container = document.querySelector('.container');
                    if (container) {
                        container.classList.add('content-loaded');
                    }
                }, 200);
                
                setTimeout(() => {
                    const background1 = document.querySelector('#background');
                    if (background1) {
                        background1.classList.add('foreground-loaded');
                    }
                }, 400);
                
                setTimeout(() => {
                    const background2 = document.querySelector('#background2');
                    if (background2) {
                        background2.classList.add('foreground-loaded');
                    }
                }, 700);
            }
        }
    });
</script>
</body>
</html>