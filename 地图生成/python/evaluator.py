import json
import re
from typing import Dict, Any, List
from openai import OpenAI


class GraphEvaluator:
    """知识图谱评价者 - 使用思维链模式评价图谱质量"""
    
    def __init__(self, client: OpenAI, model_name: str):
        self.client = client
        self.model_name = model_name
    
    def build_system_prompt(self):
        """构建系统提示词"""
        return """
你是一个专家级的知识图谱质量评价者，专门负责评价从文档中提取的知识图谱的质量。
你必须使用【思维链】模式进行严谨的逻辑推理，然后输出最终评价结果。
"""
    
    def evaluate_graph(self, full_text: str, graph_data: Dict[str, Any]) -> Dict[str, Any]:
        """评价知识图谱质量"""
        nodes = graph_data.get("nodes", [])
        relationships = graph_data.get("relationships", [])
        
        user_content = f"""请评价以下知识图谱的质量，检查是否存在问题。

你必须使用【思维链】模式进行严谨的逻辑推理，然后输出最终评价结果。

==============================================================
                    【思维链推理框架 Chain of Thought】
==============================================================

推理时要按照思维链框架，一步一步分析，最后得出评价结论：

【STEP 1: 文档理解 Document Understanding】
深入分析原始文档的内容：
- **判断文章主题**：文档的主要主题是什么？核心讨论的是什么内容？
- **判断文章类型**：文档是什么类型的文章？
- **总结主要内容**：文章的主要内容有什么？
- **分析段落内容**：文章每个段落都讲了什么？


【STEP 2: 图谱理解 Graph Understanding】
分析提取的知识图谱：
- **图谱内容分析**：
  * 图谱中包含哪些节点？每个节点的id、type、content是什么？
  * 图谱中包含哪些关系？每条关系的source、target、type是什么？
  * 图谱的整体结构如何？
- **文档与图谱对比**：文档中有哪些内容是图谱中没有提到的？
  * 对比STEP 1中分析的文档内容（主题、类型、主要内容、段落内容）和当前图谱
  * 识别文档中明确提到但图谱中完全没有涉及的内容
  * 检查文档中的重要信息点是否在图谱中有对应
  * 列出所有在图谱中缺失的文档内容（包括但不限于：关键概念、重要实体、关系描述、段落信息等）
  * 评估缺失内容的重要程度和影响

【STEP 3: 节点完整性检查 Node Completeness Check】- 【核心重点：全面覆盖优先】
这是评价过程中最重要的步骤！优先考虑全面覆盖，确保所有重要内容都有对应节点。

- **颗粒度平衡原则**：图谱的颗粒度应该适中，不要过度细化，但要确保全面覆盖
  * **颗粒度判断标准**：
    - 节点应该代表一个完整且有意义的主题或概念，而不是过于细小的属性
    - 如果一个节点包含的信息属于同一个主题的不同方面，可以保留为一个节点
    - 只有当节点包含多个明显不同的主题时，才考虑拆分
    - 例如："外貌"节点如果只包含发色、瞳色等外貌相关属性，可以保留为一个节点
    - 例如："能力设定"节点如果包含多种不同的能力类型，且这些能力在文档中是独立讨论的，才考虑拆分
  * **避免过度细化**：
    - 不要将单个概念拆分成过多细小的节点（如将"外貌"拆分为"发色"、"瞳色"、"身高"、"体型"等多个节点）
    - 不要为每个属性都创建独立节点，相关属性可以合并到一个节点中
    - 不要将描述性信息过度拆分，保持节点的语义完整性
  * **适度拆分原则**：
    - 只有当节点内容明显包含多个独立且重要的主题时，才考虑拆分
    - 拆分后的节点应该各自有足够的内容和意义，不能是空泛的节点
    - 评估拆分后的节点是否真的能提高图谱的可读性和信息价值

- **内容覆盖度评估（最高优先级）**：当前图谱是否全面涵盖了所有重要内容？
  * **这是评价的核心任务**：确保文档中的所有重要信息都在图谱中有对应节点
  * 对比STEP 1中总结的文档主要内容，检查图谱节点是否覆盖了所有关键方面
  * **是否涵盖了文档中出现的所有人物**：
    - 识别文档中提到的所有人物（包括主要角色、次要角色、NPC、历史人物等）
    - 检查每个在文档中出现的人物是否都在图谱中有对应的节点
    - 判断是否有遗漏的人物未被提取为节点
    - 列出所有缺失的人物节点（如果有）
  * **是否涵盖了所有重要概念和实体**：
    - 识别文档中提到的所有重要概念、实体、属性、特征、事件、地点等
    - 识别文档中提到的所有外貌特点
    - 检查每个重要概念是否都在图谱中有对应的节点
    - 判断是否有遗漏的概念未被提取为节点
    - 特别关注文档中明确提到但图谱中缺失的内容
  * **是否涵盖了所有重要事件和情节**：
    - 识别文档中描述的重要事件、情节、故事线
    - 检查每个重要事件是否都在图谱中有对应的节点或通过关系体现
    - 判断是否有遗漏的事件未被提取
  * **是否涵盖了所有重要设定和背景**：
    - 识别文档中提到的世界观设定、背景信息、规则体系等
    - 检查这些设定是否都在图谱中有对应的节点
    - 判断是否有遗漏的设定信息
  * **判断是否有重要内容未被提取为节点**：
    - 文档中的每个重要信息点都应该有对应的节点
    - 不要用关系来替代节点，应该为每个重要概念创建独立节点
    - 评估图谱的完整性和全面性
    - 识别哪些主要内容在图谱中缺失（如果有）

- **节点粒度指导原则**：
  * **保持语义完整性**：节点应该代表一个完整且有意义的主题，相关属性可以合并
  * **适度拆分**：只有当节点明显包含多个独立主题时才拆分，避免过度细化
  * **全面覆盖**：优先确保所有重要内容都有节点，而不是过度拆分现有节点
  * **平衡原则**：在颗粒度和覆盖度之间找到平衡，既要避免过于粗粒度，也要避免过度细化

- **文章结构还原能力评估**：用当前图谱的节点是否能还原出整个文章结构？
  * 分析图谱节点是否能够反映文档的段落结构和逻辑关系
  * 判断通过节点和关系是否能重构文档的主要内容和结构
  * 评估图谱是否保留了文档的组织方式和信息层次
  * 识别图谱在还原文章结构方面的不足（如果有）

- **节点缺失检查**：
  * 对比文档内容和图谱节点，判断是否有重要的主题/实体未被提取为节点
  * 检查文档中明确提到的关键概念是否都在图谱中
  * 识别缺失的节点类型（如：外貌属性、人际关系细节、魔术细节等）
  * 列出所有缺失的节点（如果有）

【STEP 4: 节点内容完整性检查 Node Content Completeness Check】
检查节点内容是否完整：
- **节点内容覆盖度评估**：当前节点的内容是否能完整地涵盖整个节点？
  * 对于每个节点，分析文档中与该节点相关的所有信息
  * 对比节点的content字段和文档中的相关信息，判断是否完整
  * 检查节点的content是否涵盖了文档中该主题的所有重要方面
  * 评估节点内容的完整性和全面性
  * 识别哪些节点的内容不够完整（如果有）
- **信息遗漏检查**：
  * 对于每个节点，检查其content字段是否充分描述了该主题
  * 判断节点的content是否遗漏了文档中与该主题相关的重要信息
  * 识别文档中明确提到但节点content中缺失的关键信息点
  * 评估遗漏信息的重要程度
- **内容质量评估**：
  * 识别内容不完整或过于简略的节点
  * 判断节点内容是否足够详细，能否充分说明该主题
  * 评估节点内容的准确性和相关性
- **问题汇总**：
  * 列出所有内容缺失的节点（如果有）
  * 为每个不完整的节点指出具体缺失的内容

【STEP 5: 关系准确性检查 Relationship Accuracy Check】- 【次要优先级：节点优先于关系】
**重要原则**：优先通过增加节点来细化图谱，而不是通过增加关系来连接现有节点。只有在节点已经足够细化的情况下，才考虑增加关系。

- **现有关系检查**：
  * 检查每条关系是否符合文档中的实际描述
  * 判断关系的类型（type）是否准确
  * 检查关系的方向（source → target）是否正确
  * 识别是否存在错误的关系（如：关系类型错误、方向错误、不存在的关系）
  * 列出所有错误的关系（如果有）

- **缺失关系检查（谨慎评估）**：
  * **优先考虑节点细化**：在考虑增加关系之前，先检查是否应该通过增加节点来细化信息
    - 如果两个节点之间的关系很复杂，应该考虑创建中间节点来细化关系
    - 如果关系描述包含多个信息点，应该将这些信息点提取为独立节点
  * **仅在必要时增加关系**：只有在以下情况下才建议增加关系：
    - 两个节点之间在文档中明确描述了直接关系
    - 关系类型清晰且简单（不需要中间节点）
    - 节点已经足够细化，不需要进一步拆分
  * **避免过度连接**：
    - 不要为了连接而连接，不要创建不必要的间接关系
    - 优先考虑通过增加节点来细化信息，而不是通过增加关系来连接节点
    - 如果两个节点之间需要复杂的关系描述，应该创建中间节点
  * **关系评估原则**：
    - 如果文档中描述的关系可以通过增加节点来更好地表达，优先建议增加节点
    - 只有在节点已经足够细化且关系明确简单的情况下，才建议增加关系
  * 列出所有缺失的关系（如果有，但必须符合上述原则）


【STEP 6: 综合评估 Comprehensive Evaluation】
综合以上分析，得出最终评价：
- **优先总结节点相关问题**：
  * 总结发现的节点问题（节点缺失、节点颗粒度过粗、节点需要细化）
  * 这是最重要的改进方向，优先考虑节点细化
- **其次总结节点内容问题**：
  * 总结节点内容不完整的问题
- **最后总结关系问题**：
  * 总结关系错误和缺失的问题（但这是次要的，优先考虑节点细化）
- **评估问题的严重程度**：
  * 节点缺失和节点颗粒度过粗是最严重的问题
  * 节点内容不完整是中等严重的问题
  * 关系问题相对较轻，除非是明显错误的关系
- **给出改进建议**：
  * **优先检查**：是否细化节点，节点是否覆盖全面
  * **次要建议**：补充节点内容
  * **最后建议**：修正错误关系，增加必要的关系（仅在节点已经足够细化的情况下）

==============================================================
                    【输出格式 - 严格JSON】
==============================================================

必须严格遵守 JSON 格式输出，包含 thinking（思维链推理过程）和最终评价结果。

JSON 结构：
{{
  "thinking": {{
    "step1_document_understanding": "【文档理解】分析文档的主题、关键实体...",
    "step2_graph_understanding": "【图谱理解】分析图谱的节点和关系...",
    "step3_node_completeness": "【节点完整性检查】检查是否存在节点缺失...",
    "step4_node_content_completeness": "【节点内容完整性检查】检查节点内容是否完整...",
    "step5_relationship_accuracy": "【关系准确性检查】检查关系是否正确...",
    "step6_comprehensive_evaluation": "【综合评估】总结问题并给出建议..."
  }},
  "has_issues": true/false,
  "issues": {{
    "missing_nodes": [
      {{
        "id": "建议的节点id",
        "type": "节点类型",
        "reason": "为什么这个节点应该存在",
        "suggested_content": "建议的节点内容"
      }}
    ],
    "incomplete_nodes": [
      {{
        "node_id": "现有节点的id",
        "missing_content": "缺失的内容描述",
        "suggested_addition": "建议补充的内容"
      }}
    ],
    "incorrect_relationships": [
      {{
        "relationship_index": 关系在数组中的索引,
        "issue_type": "错误类型（如：关系类型错误、方向错误、不存在的关系）",
        "current_relationship": {{
          "source": "源节点id",
          "target": "目标节点id",
          "type": "关系类型"
        }},
        "reason": "为什么这个关系是错误的",
        "suggestion": "建议的修正（如果需要删除则suggestion为null）"
      }}
    ],
    "missing_relationships": [
      {{
        "source": "源节点id",
        "target": "目标节点id",
        "type": "建议的关系类型",
        "reason": "为什么这个关系应该存在"
      }}
    ]
  }},
  "summary": "综合评价总结",
  "severity": "问题严重程度（low/medium/high）"
}}

**重要提示**：
- **核心原则：节点细化优先于关系增加**
  * 优先考虑通过增加节点和细化节点来提高图谱质量
  * 只有在节点已经足够细化的情况下，才考虑增加关系
  * 不要为了连接而连接，优先通过节点来细化信息
- **评价重点**：
  * 重点关注节点是否足够细化，是否存在粗粒度节点需要拆分
  * 重点关注是否有重要概念未被提取为节点
  * 关系检查是次要的，只有在节点已经足够细化的情况下才重点关注关系
- 如果没有发现问题，has_issues 应为 false，issues 中的数组应为空
- 如果发现问题，has_issues 应为 true，并在相应的数组中列出问题
  * 优先在 missing_nodes 中列出需要增加的节点和需要细化的节点
  * 谨慎在 missing_relationships 中列出缺失的关系，确保这些关系是必要的且节点已经足够细化
- thinking 字段必须完整记录6步推理过程，特别强调节点细化的分析
- 必须且只能返回纯 JSON 格式，不要包含Markdown代码块或其他文字

原始文档内容：
{full_text}

提取的知识图谱：
{json.dumps(graph_data, ensure_ascii=False, indent=2)}
"""

        try:
            response = self.client.chat.completions.create(
                model=self.model_name,
                messages=[
                    {"role": "system", "content": self.build_system_prompt()},
                    {"role": "user", "content": user_content}
                ],
               temperature=0.4,
            )

            content = response.choices[0].message.content.strip()
            
            # 尝试解析 JSON
            try:
                json_match = re.search(r'\{.*\}', content, re.DOTALL)
                if json_match:
                    json_str = json_match.group()
                    parsed_result = json.loads(json_str)
                    return parsed_result
                else:
                    print("  ! 警告：未能从评价结果中找到 JSON 对象，返回原始文本")
                    return {"has_issues": True, "raw_result": content}
            except json.JSONDecodeError:
                print("  ! 警告：评价结果不是有效的 JSON，返回原始文本")
                return {"has_issues": True, "raw_result": content}

        except Exception as e:
            print(f"  ! 评价者 API 调用错误: {e}")
            return None

