<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
    <title>3D Timeline - Lightning Beam Style</title>
    <style>
        /* 样式保持不变 */
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            cursor: grab;
            background-color: #020205;
            color: #fff;
        }

        body.grabbing {
            cursor: grabbing;
        }

        body.pointer {
            cursor: pointer !important;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            z-index: 10;
            transition: all 0.5s ease;
            color: #fff;
            mix-blend-mode: difference;
        }

        h1 {
            font-weight: 300;
            letter-spacing: 2px;
            margin: 0;
            text-transform: uppercase;
            font-size: 1.2rem;
            display: inline-block;
            padding-bottom: 5px;
            border-bottom: 1px solid #00ffff;
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        p {
            font-size: 0.8rem;
            opacity: 0.8;
            margin-top: 5px;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            letter-spacing: 5px;
            transition: opacity 0.5s;
            pointer-events: none;
            color: #00ffff;
            text-shadow: 0 0 15px #00ffff;
        }
    </style>
</head>

<body>

<div id="ui">
    <h1 id="ui-title">MANUAL TRIGGER</h1>
    <p id="ui-desc">Press [1] to Check & Unlock</p>
</div>

<div class="loading" id="loading">LOADING SHADERS...</div>
<div id="canvas-container"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/shaders/CopyShader.js"></script>
<script
        src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/shaders/LuminosityHighPassShader.js"></script>
<script
        src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/postprocessing/ShaderPass.js"></script>
<script
        src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/postprocessing/UnrealBloomPass.js"></script>

<script>
    // --- JSON 数据定义 (保持不变) ---
    const timelineData = {
        "roots": ["node_1"],
        "nodes": [
            {
                "id": "node_1",
                "status": "unlocked",
                "unlockCondition": [],
                "pos": [0, -100],
                "children": ["node_2", "node_3"],
                "info": {"title": "START", "desc": "Project Initialization", "url": ""}
            },
            {
                "id": "node_2",
                "status": "locked",
                "unlockCondition": ["node_1"],
                "pos": [-60, -250],
                "children": ["node_4" , "node_7"],
                "info": {"title": "BRANCH A", "desc": "Development Phase", "url": ""}
            },
            {
                "id": "node_3",
                "status": "locked",
                "unlockCondition": ["node_1"],
                "pos": [60, -300],
                "children": ["node_4"],
                "info": {"title": "BRANCH B", "desc": "Design Phase", "url": ""}
            },
            {
                "id": "node_7",
                "status": "locked",
                "unlockCondition": ["node_4"],
                "pos": [-180, -300],
                "info": {"title": "BRANCH B", "desc": "Design Phase", "url": ""}
            },
            {
                "id": "node_4",
                "status": "locked",
                "unlockCondition": ["node_2", "node_3"],
                "pos": [0, -450],
                "children": ["node_5"],
                "info": {"title": "MERGE", "desc": "Integration (Wait for A & B)", "url": ""}
            },
            {
                "id": "node_5",
                "status": "locked",
                "unlockCondition": ["node_4"],
                "pos": [0, -600],
                "children": [],
                "info": {"title": "RELEASE", "desc": "Version 1.0 Launch", "url": ""}
            }
        ]
    };

    // --- 全局变量 ---
    const nodeAnimRegistry = {};
    const edgeAnimRegistry = [];
    const clock = new THREE.Clock();
    const TIME_SCALE = 60.0;

    // [新增] 闪电特效配置
    const LIGHTNING_SEGMENTS = 20; // 闪电段数，越多越细腻
    const LIGHTNING_STRANDS = 3;   // 每个连接由几根闪电组成
    const LIGHTNING_COLOR = 0x88ffff; // 青色光辉

    let buildingIdCounter = 0;
    let buildingRegistry = new Map();
    let zoneToBuildings = new Map();
    const buildingHistory = new Map(); // Key: buildingId, Value: { pos, rot, scale }
    const BUILDING_AVOID_RADIUS = 120;
    const BUILDING_ANIMATION_SPEED = 0.4;
    const VISIBLE_ZONE_RADIUS = 3;
    const BUILDING_ZONE_SIZE = 200;

    // --- SHADER 管理系统 ---
    const loadedShaders = {};
    const shaderFiles = {
        noise: 'shaders/noise.glsl',
        cloudVert: 'shaders/cloud_vert.glsl',
        cloudFrag: 'shaders/cloud_frag.glsl',
        particlesVert: 'shaders/particles_vert.glsl',
        particlesFrag: 'shaders/particles_frag.glsl',
        volFogVert: 'shaders/vol_fog_vert.glsl',
        volFogFrag: 'shaders/vol_fog_frag.glsl',
        bloomVert: 'shaders/bloom_vert.glsl',
        bloomFrag: 'shaders/bloom_frag.glsl'
    };

    // --- 配置参数 ---
    const config = {
        "spacingZ": 2,
        "renderRange": 20,
        "laneCount": 5,
        "laneDist": 60,
        "maxPixelRatio": 1.5,
        "bgColor": 0xb5d0d9,
        "fogColor": 0xb5d0d9,
        "cloudBaseColor": 0xb5d0d9,
        "cloudHighlightColor": 0xb5d0d9,
        "heightFogDensity": 0.008,
        "heightFogBase": -200,
        "mainBlockColor": 0x64b4ff,
        "bgBlockColor": 0x95d9fe,
        "lineColor": 0x222222,
        "mainEdgeColor": 0x51d0ff,
        "dimEdgeColor": 0x7cb7c0,
        "textColor": "#####ffffff",
        "uiTitle": "MANUAL UNLOCK",
        "uiDesc": "Wait for animations, then press [1]",
        "seed": 325.52345
    };

    const globalUniforms = {
        time: {value: 0},
        cloudBaseColor: {value: new THREE.Color(config.cloudBaseColor)},
        cloudHighlightColor: {value: new THREE.Color(config.cloudHighlightColor)},
        fogColor: {value: new THREE.Color(config.fogColor)}
    };

    let scene, camera, renderer;
    let bloomComposer, finalComposer;
    let cloudMesh;
    let scrollPos = 0, targetScrollPos = 0;
    let cameraOffsetX = 0, targetCameraOffsetX = 0;
    let cameraHeight = 100, targetCameraHeight = 100;
    let generatedBuildingZones = new Set();
    const affectedZones = new Set();   // [新增] 记录发生过倒塌的区域 ID
    let isDragging = false, previousMouseY = 0, previousMouseX = 0;
    let objects = [], mats = {};
    const BLOOM_LAYER = 1;
    let allParticles = [];
    const particleGeo = new THREE.SphereGeometry(0.3, 6, 6);
    let particleMat;
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let interactiveObjects = [], hoveredObject = null;

    class SeededRandom {
        constructor(seed) {
            this.seed = seed;
        }

        next() {
            this.seed = (this.seed * 9301 + 49297) % 233280;
            return this.seed / 233280;
        }
    }

    async function loadAllShaders() {
        const promises = Object.entries(shaderFiles).map(async ([key, url]) => {
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Failed to load ${url}`);
                const text = await response.text();
                loadedShaders[key] = text;
            } catch (error) {
                console.error(error);
                alert(`Error loading shader: ${url}`);
            }
        });
        await Promise.all(promises);
        init();
    }

    loadAllShaders();

    function init() {
        const container = document.getElementById('canvas-container');
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(25, window.innerWidth / window.innerHeight, 10, 20000);

        renderer = new THREE.WebGLRenderer({antialias: true, alpha: false});
        renderer.setSize(window.innerWidth, window.innerHeight);
        const dpr = Math.min(window.devicePixelRatio, config.maxPixelRatio);
        renderer.setPixelRatio(dpr);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        window.addEventListener('resize', onWindowResize, false);
        document.addEventListener('wheel', onDocumentMouseWheel, {passive: false});
        document.addEventListener('mousedown', onMouseDown, false);
        document.addEventListener('mouseup', onMouseUp, false);
        document.addEventListener('mousemove', onMouseMove, false);
        document.addEventListener('mouseleave', onMouseUp, false);
        document.addEventListener('click', onMouseClick, false);
        document.addEventListener('keydown', (e) => {
            if (e.key === '1') checkAndAutoUnlock();
        });

        setupSceneMode();

        document.getElementById('loading').style.opacity = 0;
        setTimeout(() => document.getElementById('loading').style.display = 'none', 500);

        animate();
    }

    function getUnlockedNodePositions() {
        const positions = [];
        for (const nodeId in nodeAnimRegistry) {
            const node = nodeAnimRegistry[nodeId];
            if (node.status === 'unlocked' || node.status === 'popping') {
                positions.push({x: node.group.position.x, z: node.group.position.z});
            }
        }
        return positions;
    }

    function isTooCloseToNodes(x, z, nodePositions) {
        for (const nodePos of nodePositions) {
            const dx = x - nodePos.x;
            const dz = z - nodePos.z;
            if (Math.sqrt(dx * dx + dz * dz) < BUILDING_AVOID_RADIUS) return true;
        }
        return false;
    }

    function removeBuildingsNearNode(nodeX, nodeZ) {
        buildingRegistry.forEach((building, buildingId) => {
            const dx = building.position.x - nodeX;
            const dz = building.position.z - nodeZ;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist < BUILDING_AVOID_RADIUS) {
                const state = building.userData.animState;
                if (state !== 'disappearing' && state !== 'hidden' && state !== 'collapsing' && state !== 'collapsed') {

                    building.userData.animState = 'collapsing';
                    building.userData.animProgress = 0;

                    // --- [新增] 标记该区域已受到影响 ---
                    if (building.userData.zone !== undefined) {
                        affectedZones.add(building.userData.zone);
                    }
                    // ----------------------------------

                    let pushDir = new THREE.Vector3(dx, 0, dz).normalize();
                    if (pushDir.lengthSq() < 0.01) {
                        pushDir.set(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();
                    }

                    const collapseAxis = new THREE.Vector3().crossVectors(pushDir, new THREE.Vector3(0, 1, 0)).normalize();

                    if (!building.userData.collapseData) building.userData.collapseData = {};
                    building.userData.collapseData.axis = collapseAxis;
                }
            }
        });
    }

    function checkAndAutoUnlock() {
        console.log("Checking conditions...");
        let unlockedCount = 0;
        timelineData.nodes.forEach(nodeData => {
            const registryItem = nodeAnimRegistry[nodeData.id];
            if (!registryItem || registryItem.status === 'unlocked' || registryItem.status === 'popping') return;
            const conditions = nodeData.unlockCondition || [];
            let allMet = true;
            if (conditions.length > 0) {
                for (let reqId of conditions) {
                    const reqNode = nodeAnimRegistry[reqId];
                    if (!reqNode || reqNode.status !== 'unlocked') {
                        allMet = false;
                        break;
                    }
                }
            }
            if (allMet) {
                unlockNode(nodeData.id);
                unlockedCount++;
            }
        });
        if (unlockedCount === 0) console.log("No new nodes met conditions yet.");
    }

    function unlockNode(nodeId) {
        const registryItem = nodeAnimRegistry[nodeId];
        if (!registryItem || registryItem.status !== 'locked') return;
        let hasIncomingEdges = false;
        edgeAnimRegistry.forEach(edge => {
            if (edge.childId === nodeId && edge.status === 'hidden') {
                edge.status = 'growing';
                hasIncomingEdges = true;
            }
        });
        if (!hasIncomingEdges) registryItem.status = 'popping';
        else registryItem.targetStatus = 'unlocked';
        removeBuildingsNearNode(registryItem.group.position.x, registryItem.group.position.z);
    }

    function setupSceneMode() {
        scene.add(camera);
        clearScene();
        globalUniforms.cloudBaseColor.value.setHex(config.cloudBaseColor);
        globalUniforms.cloudHighlightColor.value.setHex(config.cloudHighlightColor);
        globalUniforms.fogColor.value.setHex(config.fogColor);
        document.getElementById('ui-title').innerText = config.uiTitle;
        document.getElementById('ui-desc').innerHTML = config.uiDesc + "<br>MERGE 节点需要等待 A 和 B 同时完成<br>左上↔右下：移动 • 按 '1'：解锁下一步";
        scene.background = new THREE.Color(config.bgColor);

        initMaterials();
        setupLights();
        createCloudFloor();
        setupPostProcessing();
        createAtmosphericParticles();
        buildMainLineFromJSON();
        createCrossingLines();

        interactiveObjects = [];
        objects.forEach(obj => {
            obj.traverse(child => {
                if (child.userData && child.userData.isInteractive) interactiveObjects.push(child);
            });
        });
    }

    function clearScene() {
        for (let i = objects.length - 1; i >= 0; i--) {
            const obj = objects[i];
            scene.remove(obj);
            disposeHierarchy(obj);
        }
        if (cloudMesh) {
            scene.remove(cloudMesh);
            if (cloudMesh.geometry) cloudMesh.geometry.dispose();
            if (cloudMesh.material) cloudMesh.material.dispose();
            cloudMesh = null;
        }
        objects = [];
        allParticles = [];
        generatedBuildingZones.clear();
        buildingRegistry.clear();
        zoneToBuildings.clear();
        buildingIdCounter = 0;
        const oldLights = scene.children.filter(c => c.isLight || c.type === 'GridHelper');
        oldLights.forEach(l => {
            scene.remove(l);
            if (l.dispose) l.dispose();
        });
    }

    function disposeHierarchy(node) {
        node.traverse((child) => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
                if (Array.isArray(child.material)) child.material.forEach(m => {
                    if (m.map) m.map.dispose();
                    m.dispose();
                });
                else {
                    if (child.material.map) child.material.map.dispose();
                    child.material.dispose();
                }
            }
        });
    }

    function createCloudFloor() {
        const geometry = new THREE.PlaneGeometry(8000, 8000, 100, 100);
        const fragShader = loadedShaders.cloudFrag.replace('#include <noise>', loadedShaders.noise);
        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: globalUniforms.time,
                uBaseColor: globalUniforms.cloudBaseColor,
                uHighlightColor: globalUniforms.cloudHighlightColor,
                uFogColor: globalUniforms.fogColor,
                uCameraPos: {value: camera.position}
            },
            vertexShader: loadedShaders.cloudVert,
            fragmentShader: fragShader,
            transparent: true, depthWrite: false, side: THREE.DoubleSide
        });
        cloudMesh = new THREE.Mesh(geometry, material);
        cloudMesh.rotation.x = -Math.PI / 2;
        cloudMesh.position.y = config.heightFogBase - 50;
        scene.add(cloudMesh);
    }

    function getVolumetricFogShaderLogic() {
        return (shader) => {
            shader.uniforms.uTime = globalUniforms.time;
            shader.uniforms.hFogColor = globalUniforms.fogColor;
            shader.uniforms.hFogDensity = {value: config.heightFogDensity};
            shader.uniforms.hFogBase = {value: config.heightFogBase};
            const fragHead = `
                uniform float uTime;
                uniform vec3 hFogColor;
                uniform float hFogDensity;
                uniform float hFogBase;
                varying vec3 vWorldPosition;
                ${loadedShaders.noise}
            `;
            shader.vertexShader = `
                varying vec3 vWorldPosition;
                ${shader.vertexShader}
            `.replace(
                `#include <begin_vertex>`,
                `#include <begin_vertex>
                 ${loadedShaders.volFogVert}`
            );
            shader.fragmentShader = `
                ${fragHead}
                ${shader.fragmentShader}
            `.replace(
                `#include <fog_fragment>`,
                `
                ${loadedShaders.volFogFrag}
                #include <fog_fragment>
                `
            );
        };
    }

    function initMaterials() {
        const shaderLogic = getVolumetricFogShaderLogic();
        mats = {};
        particleMat = new THREE.MeshBasicMaterial({
            color: config.mainEdgeColor,
            transparent: true,
            opacity: 1.0,
            blending: THREE.AdditiveBlending
        });

        const mainBoxColor = new THREE.Color(config.mainBlockColor);
        mats.mainBox = new THREE.MeshBasicMaterial({color: mainBoxColor});
        mats.mainBox.onBeforeCompile = shaderLogic;

        const bgBoxColor = new THREE.Color(config.bgBlockColor);
        mats.bgBox = new THREE.MeshLambertMaterial({color: bgBoxColor});
        mats.bgBox.onBeforeCompile = shaderLogic;

        mats.line = new THREE.LineBasicMaterial({color: config.mainEdgeColor, transparent: true, opacity: 0.95});
        mats.line.onBeforeCompile = shaderLogic;

        // [新增] 闪电特效材质
        mats.lightning = new THREE.LineBasicMaterial({
            color: LIGHTNING_COLOR,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });
        // 注意：这里也可以选择加入 shaderLogic 以支持体积雾，但为了保持极亮效果，通常闪电本身不应受雾太强影响
        // mats.lightning.onBeforeCompile = shaderLogic;

        const glowEdgeColor = new THREE.Color(config.mainEdgeColor);
        glowEdgeColor.multiplyScalar(2.0);
        mats.glowEdges = new THREE.LineBasicMaterial({
            color: glowEdgeColor,
            linewidth: 2,
            transparent: true,
            opacity: 1.0
        });
        mats.glowEdges.onBeforeCompile = shaderLogic;

        const dimEdgeColor = new THREE.Color(config.dimEdgeColor);
        mats.dimEdges = new THREE.LineBasicMaterial({
            color: dimEdgeColor,
            transparent: true,
            opacity: 0.85,
            linewidth: 2
        });
        mats.dimEdges.onBeforeCompile = shaderLogic;
        mats.bgEdges = mats.dimEdges;
        mats.mainEdges = mats.glowEdges;
        mats.person = new THREE.MeshBasicMaterial({color: 0x00aaaa});
        mats.person.onBeforeCompile = shaderLogic;
    }

    function setupLights() {
        scene.add(new THREE.AmbientLight(0x222222, 5));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.name = "mainLight";
        const sunAngle = Math.PI / 3;
        const sunDist = 2000;
        const sunH = 1500;
        dirLight.position.set(Math.cos(sunAngle) * sunDist, sunH, Math.sin(sunAngle) * sunDist);
        dirLight.target.position.set(0, 0, 0);
        dirLight.castShadow = true;
        dirLight.shadowBlur = false;
        dirLight.shadow.mapSize.width = 4096;
        dirLight.shadow.mapSize.height = 4096;
        const d = 4000;
        dirLight.shadow.camera.left = -d;
        dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d;
        dirLight.shadow.camera.bottom = -d;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 3000;
        scene.add(dirLight);
        scene.add(dirLight.target);
    }

    const GradientShader = {
        uniforms: {
            tDiffuse: {value: null},
            uDarkness: {value: 0.2}, // 左下角的亮度倍率 (0.4 = 40% 亮度)
            uBrightness: {value: 1.3} // 右上角的亮度倍率 (1.3 = 130% 亮度)
        },
        vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
        fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float uDarkness;
                uniform float uBrightness;
                varying vec2 vUv;
                void main() {
                    vec4 color = texture2D(tDiffuse, vUv);

                    // 计算梯度：(x + y) / 2.0
                    // 左下角为 0.0，右上角为 1.0
                    float gradient = (vUv.x + vUv.y) * 0.5;

                    // 使用 mix 线性插值计算当前的亮度倍率
                    float strength = mix(uDarkness, uBrightness, gradient);

                    // 应用亮度变化
                    gl_FragColor = vec4(color.rgb * strength, color.a);
                }
            `
    };

    function setupPostProcessing() {
        const dpr = Math.min(window.devicePixelRatio, config.maxPixelRatio);
        const width = window.innerWidth;
        const height = window.innerHeight;
        const renderScene = new THREE.RenderPass(scene, camera);

        // Bloom 通道配置
        const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(width * dpr, height * dpr), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = 1.5;
        bloomPass.radius = 0.5;

        bloomComposer = new THREE.EffectComposer(renderer);
        bloomComposer.renderToScreen = false;
        bloomComposer.addPass(renderScene);
        bloomComposer.addPass(bloomPass);

        // 最终合成 Pass (Bloom + Base)
        const finalPass = new THREE.ShaderPass(
            new THREE.ShaderMaterial({
                uniforms: {
                    baseTexture: {value: null},
                    bloomTexture: {value: bloomComposer.renderTarget2.texture}
                },
                vertexShader: loadedShaders.bloomVert,
                fragmentShader: loadedShaders.bloomFrag
            }), "baseTexture"
        );
        finalPass.needsSwap = true;

        // [修改] Final Composer 配置
        finalComposer = new THREE.EffectComposer(renderer);
        finalComposer.addPass(renderScene); // 1. 渲染基础场景
        const gradientPass = new THREE.ShaderPass(GradientShader);
        finalComposer.addPass(gradientPass); // 3. 应用左暗右亮滤镜
        finalComposer.addPass(finalPass);   // 2. 合并辉光效果

        // [新增] 添加渐变滤镜 Pass


        bloomComposer.setSize(width, height);
        bloomComposer.setPixelRatio(dpr);
        finalComposer.setSize(width, height);
        finalComposer.setPixelRatio(dpr);
    }

    function enableBloom(obj) {
        obj.layers.set(BLOOM_LAYER);
    }

    function spawnFlowingParticles(startPointLocal, endVectorLocal, parentGroup, count = 4, visible = true) {
        const len = endVectorLocal.length();
        const density = Math.max(count, Math.floor(len / 40));
        const dirNorm = endVectorLocal.clone().normalize();
        let sideVec = new THREE.Vector3().crossVectors(dirNorm, new THREE.Vector3(0, 1, 0)).normalize();
        if (sideVec.lengthSq() < 0.01) sideVec = new THREE.Vector3(1, 0, 0);
        const particleGroup = new THREE.Group();
        particleGroup.visible = visible;
        parentGroup.add(particleGroup);
        for (let i = 0; i < density; i++) {
            const pMesh = new THREE.Mesh(particleGeo, particleMat);
            enableBloom(pMesh);
            pMesh.userData.isParticle = true;
            pMesh.userData.type = 'flow';
            pMesh.userData.flowData = {
                start: startPointLocal.clone(), endVec: endVectorLocal, sideVec: sideVec,
                sideModifier: i % 2 === 0 ? 1 : -1, progress: Math.random(),
                speed: 0.002 + Math.random() * 0.005, phase: Math.random() * Math.PI * 2,
                wobbleSpeed: 2.0 + Math.random() * 4.0, wobbleAmp: 0.5 + Math.random() * 0.8
            };
            pMesh.position.copy(pMesh.userData.flowData.start);
            particleGroup.add(pMesh);
            allParticles.push(pMesh);
        }
        return particleGroup;
    }

    function createAtmosphericParticles() {
        const CONFIG = {
            count: 300000,
            rangeX: 12000,
            rangeZ: 2000,
            height: 900,
            bottom: -350,
            baseSize: 3.0,
            speedMin: 0.02,
            speedMax: 0.2
        };
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const attrData = [];
        for (let i = 0; i < CONFIG.count; i++) {
            positions.push((Math.random() - 0.5) * CONFIG.rangeX, 0, (Math.random() - 0.5) * CONFIG.rangeZ);
            const r = Math.random();
            const speedFactor = Math.pow(r, 9.0);
            const speed = CONFIG.speedMin + speedFactor * (CONFIG.speedMax - CONFIG.speedMin);
            attrData.push(speed, Math.random() * 1000.0, 0.5 + Math.random() * 1.0);
        }
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('aData', new THREE.Float32BufferAttribute(attrData, 3));
        const fragShader = loadedShaders.particlesFrag.replace('#include <noise>', loadedShaders.noise);
        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: globalUniforms.time,
                uColor: {value: new THREE.Color(config.mainEdgeColor)},
                hFogColor: globalUniforms.fogColor,
                hFogDensity: {value: config.heightFogDensity},
                hFogBase: {value: config.heightFogBase},
                uHeight: {value: CONFIG.height},
                uBottom: {value: CONFIG.bottom},
                uBaseSize: {value: CONFIG.baseSize}
            },
            transparent: true, depthWrite: false, blending: THREE.AdditiveBlending,
            vertexShader: loadedShaders.particlesVert,
            fragmentShader: fragShader
        });
        const particleSystem = new THREE.Points(geometry, material);
        particleSystem.raycast = () => {
        };
        scene.add(particleSystem);
        objects.push(particleSystem);
    }


    // [核心修改] 构建主线，支持闪电特效
    function buildMainLineFromJSON() {
        const boxGeo = new THREE.BoxGeometry(1, 1, 1);
        const personGeo = new THREE.ConeGeometry(0.15, 0.8, 8);
        const nodeLookup = new Map();
        timelineData.nodes.forEach(node => {
            const group = new THREE.Group();
            const x = node.pos[0];
            const z = node.pos[1];
            const y = Math.random() * 5;
            group.position.set(x, y, z);
            const isUnlocked = (node.status === 'unlocked');
            if (!isUnlocked) group.scale.set(0.001, 0.001, 0.001);
            group.userData = {type: 'mainNode', baseY: y, nodeId: node.id};
            const scaleMult = 5;
            const mainSx = 5 * scaleMult;
            const mainSy = 1 * scaleMult * 0.5;
            const mainSz = 3 * scaleMult;
            const platform = new THREE.Mesh(boxGeo, mats.mainBox);
            platform.scale.set(mainSx, mainSy, mainSz);
            platform.castShadow = true;
            platform.receiveShadow = true;
            platform.userData = {
                isInteractive: true,
                originScale: new THREE.Vector3(mainSx, mainSy, mainSz),
                storyData: node.info,
                nodeId: node.id
            };
            const platformEdges = new THREE.LineSegments(new THREE.EdgesGeometry(boxGeo), mats.mainEdges);
            enableBloom(platformEdges);
            platform.add(platformEdges);
            group.add(platform);
            const lineHeight = 60 + Math.random() * 5;
            const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, lineHeight, 0)]), mats.glowEdges);
            enableBloom(line);
            line.position.set(mainSx / 2 - 0.5, mainSy / 2, mainSz / 2 - 0.5);
            group.add(line);
            if (node.info && node.info.title) {
                const panelMat = new THREE.MeshBasicMaterial({
                    map: createTextTexture(node.info.title, node.info.desc),
                    transparent: true,
                    depthWrite: true,
                    blending: THREE.AdditiveBlending
                });
                const panel = new THREE.Mesh(new THREE.PlaneGeometry(16, 16), panelMat);
                panel.position.set(mainSx / 2 - 0.5 + 4, mainSy / 2 + lineHeight, mainSz / 2 - 0.5);
                panel.rotation.y = -Math.PI / 4;
                group.add(panel);
            }
            const person = new THREE.Mesh(personGeo, mats.person);
            person.position.set(0, mainSy / 2 + 0.4, 0);
            group.add(person);
            scene.add(group);
            objects.push(group);
            nodeLookup.set(node.id, group);
            nodeAnimRegistry[node.id] = {
                group: group,
                status: node.status,
                targetStatus: node.status,
                scaleProgress: isUnlocked ? 1.0 : 0.0
            };
        });

        timelineData.nodes.forEach(node => {
            if (node.children && node.children.length > 0) {
                const startGroup = nodeLookup.get(node.id);
                if (!startGroup) return;
                node.children.forEach(childId => {
                    const endGroup = nodeLookup.get(childId);
                    if (endGroup) {
                        const startWorld = startGroup.position.clone();
                        const endWorld = endGroup.position.clone();
                        const vecLocal = endWorld.sub(startWorld);
                        const childStatus = nodeAnimRegistry[childId].status;
                        const isChildUnlocked = (childStatus === 'unlocked');

                        // [修改] 创建多条 Lightning 线，而不是单条直线
                        const lightningLines = [];
                        for (let i = 0; i < LIGHTNING_STRANDS; i++) {
                            const pts = new Float32Array((LIGHTNING_SEGMENTS + 1) * 3);
                            const lGeo = new THREE.BufferGeometry();
                            lGeo.setAttribute('position', new THREE.BufferAttribute(pts, 3));

                            const lMat = mats.lightning.clone();
                            // 让核心线（i=0）更亮，外部线更透明
                            lMat.opacity = (i === 0) ? 0.9 : 0.4;

                            const lLine = new THREE.Line(lGeo, lMat);
                            lLine.frustumCulled = false;
                            lLine.userData = {isLightning: true, strandIndex: i};
                            enableBloom(lLine);

                            startGroup.add(lLine);
                            lightningLines.push(lLine);
                        }

                        // 粒子效果保持不变
                        const pGroup = spawnFlowingParticles(new THREE.Vector3(0, 0, 0), vecLocal, startGroup, 50, isChildUnlocked);

                        edgeAnimRegistry.push({
                            lightningLines: lightningLines, // 存储闪电线数组
                            targetVec: vecLocal,
                            particleGroup: pGroup,
                            childId: childId,
                            status: isChildUnlocked ? 'shown' : 'hidden',
                            progress: isChildUnlocked ? 1.0 : 0.0
                        });
                    }
                });
            }
        });
    }
    function createCrossingLines() {
        const CONFIG = {
            count: 3000,           // 线条数量
            rangeX: 8000,          // 分布范围 X
            rangeZ: 8000,          // 分布范围 Z
            yTop: 2000,            // 线条顶部高度
            yBottom: -2000,        // 线条底部高度
            tiltRange: 400,        // 倾斜幅度 (制造交错感)
            color: 0x88ccff,       // 线条颜色 (淡青色)
            baseOpacity: 0.05,     // 基础透明度
            animSpeed: 0.5         // 闪烁速度
        };

        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const animAttributes = []; //存储每条线的动画参数 (速度, 相位)

        for (let i = 0; i < CONFIG.count; i++) {
            // 随机中心点
            const cx = (Math.random() - 0.5) * CONFIG.rangeX;
            const cz = (Math.random() - 0.5) * CONFIG.rangeZ;

            // 顶部点 (稍微偏移)
            const topX = cx + (Math.random() - 0.5) * CONFIG.tiltRange;
            const topZ = cz + (Math.random() - 0.5) * CONFIG.tiltRange;

            // 底部点 (反向偏移，形成交叉)
            const botX = cx + (Math.random() - 0.5) * CONFIG.tiltRange;
            const botZ = cz + (Math.random() - 0.5) * CONFIG.tiltRange;

            // 存入两个顶点构成一条线
            positions.push(topX, CONFIG.yTop, topZ);
            positions.push(botX, CONFIG.yBottom, botZ);

            // 动画参数: [闪烁速度, 随机相位]
            // 同一条线的两个顶点必须共享相同的动画参数
            const speed = 0.5 + Math.random() * 1.5;
            const phase = Math.random() * Math.PI * 2;

            animAttributes.push(speed, phase);
            animAttributes.push(speed, phase);
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('aAnim', new THREE.Float32BufferAttribute(animAttributes, 2));

        // 自定义 Shader 实现透明度呼吸动画
        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: globalUniforms.time,
                uColor: { value: new THREE.Color(CONFIG.color) },
                uBaseOpacity: { value: CONFIG.baseOpacity },
                hFogColor: globalUniforms.fogColor,  // 复用现有的雾参数
                hFogDensity: { value: config.heightFogDensity },
                hFogBase: { value: config.heightFogBase }
            },
            transparent: true,
            depthWrite: true,
            blending: THREE.AdditiveBlending, //以此模式混合，会让重叠部分更亮
            vertexShader: `
                attribute vec2 aAnim;
                varying float vAlpha;
                varying float vDist;
                uniform float uTime;

                void main() {
                    vec3 transformed = position;
                    vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);
                    gl_Position = projectionMatrix * mvPosition;

                    // 计算呼吸动画: sin(time * speed + phase)
                    // 将结果归一化到 [0.3, 1.0] 之间，保证线不会完全消失
                    float blink = 0.5 + 0.5 * sin(uTime * aAnim.x + aAnim.y);
                    vAlpha = 0.3 + 0.7 * blink;

                    // 简单的距离雾计算 (让远处的线变淡)
                    vDist = -mvPosition.z;
                }
            `,
            fragmentShader: `
                uniform vec3 uColor;
                uniform float uBaseOpacity;
                uniform vec3 hFogColor;
                varying float vAlpha;
                varying float vDist;

                void main() {
                    // 简单的线性雾衰减
                    float fogFactor = smoothstep(200.0, 4000.0, vDist);

                    // 最终 Alpha = 基础透明度 * 动画波动 * (1 - 雾遮挡)
                    float finalAlpha = uBaseOpacity * vAlpha * (1.0 - fogFactor);

                    if (finalAlpha < 0.01) discard;

                    gl_FragColor = vec4(uColor, finalAlpha);
                }
            `
        });

        const linesMesh = new THREE.LineSegments(geometry, material);
        // 不参与辉光，保持背景的细腻感 (如果想发光，改为 true)
        enableBloom(linesMesh);

        scene.add(linesMesh);
        objects.push(linesMesh); // 加入 objects 数组以便 clearScene 时自动清理
    }
    function createRandomBuildings(zone) {
        const boxGeo = new THREE.BoxGeometry(1, 1, 1);
        const totalWidth = config.laneCount * config.laneDist;
        const centerZ = zone * BUILDING_ZONE_SIZE;
        const rng = new SeededRandom(config.seed + zone);
        const nodePositions = getUnlockedNodePositions(); // 获取当前所有已解锁节点的位置
        const zoneBuildingIds = [];

        // --- Bottom Buildings (底部建筑) ---
        const bottomCount = 66 + Math.floor(rng.next() * 8);
        for (let k = 0; k < bottomCount; k++) {
            // 1. 生成确定性 ID
            const uniqueId = `z${zone}_b${k}`;

            // 2. 计算位置 (【关键修改】移除 do...while 循环)
            // 我们不再让建筑“躲避”节点生成，而是让它固定生成在随机位置。
            // 这样无论节点是否解锁，z1_b5 永远在同一个坐标，保证了 ID 和位置的永久绑定。
            const bZPos = centerZ + (rng.next() - 0.5) * BUILDING_ZONE_SIZE * 2;
            const bXPos = (rng.next() - 0.5) * totalWidth * 10;
            // 消耗掉原本用于 attempts 的逻辑，这里不再需要 attempts

            // 3. 消耗属性随机数 (保持 RNG 序列对齐)
            const animSpeed = 0.075 + rng.next() * 0.26;
            const animPhase = rng.next() * Math.PI * 2;
            const animAmp = 2 + rng.next() * 4;
            const targetAngle = (Math.PI / 18) + (rng.next() * Math.PI / 6);
            const sinkAmount = 100 + rng.next() * 300;
            const h = 30 + rng.next() * 500;
            const w = 10 + rng.next() * 20;

            // 倾斜随机数
            let tiltX = 0, tiltZ = 0;
            let hasTilt = false;
            if (rng.next() < 0.1) {
                const minTilt = 0.08;
                const maxTilt = 0.35;
                tiltX = (minTilt + rng.next() * (maxTilt - minTilt)) * (rng.next() > 0.5 ? 1 : -1);
                tiltZ = (minTilt + rng.next() * (maxTilt - minTilt)) * (rng.next() > 0.5 ? 1 : -1);
                hasTilt = true;
            }

            // 4. 【核心修改】精确过滤逻辑
            // 计算该位置是否在任意已解锁节点的“爆炸半径”内
            const isInsideClearRadius = isTooCloseToNodes(bXPos, bZPos, nodePositions);
            const hasHistory = buildingHistory.has(uniqueId);

            // 逻辑分支：
            if (isInsideClearRadius) {
                // 情况 A: 在爆炸范围内，且有历史记录 -> 说明它是废墟 -> 允许生成（后面会恢复状态）
                if (hasHistory) {
                    // Pass (Proceed to generate)
                }
                // 情况 B: 在爆炸范围内，但没有历史记录 -> 说明它是被清理掉的完好建筑 -> 跳过
                else {
                    continue;
                }
            }
            // 情况 C: 不在爆炸范围内 -> 正常生成背景建筑

            // --- 以下是生成逻辑 (保持不变) ---
            const bGroup = new THREE.Group();
            const bYBase = -240 - rng.next() * 200;
            const disappearOffset = -300;

            bGroup.position.set(bXPos, bYBase + disappearOffset, bZPos);

            bGroup.userData = {
                buildingId: uniqueId,
                baseY: bYBase,
                type: 'bottom',
                animSpeed: animSpeed,
                animPhase: animPhase,
                animAmp: animAmp,
                animState: 'appearing',
                animProgress: 0,
                zone: zone,
                collapseData: {
                    axis: new THREE.Vector3(1, 0, 0),
                    targetAngle: targetAngle,
                    sinkAmount: sinkAmount
                }
            };

            const bMesh = new THREE.Mesh(boxGeo, mats.bgBox);
            bMesh.scale.set(w, h, w);
            bMesh.position.set(0, h / 2, 0);
            bGroup.add(bMesh);

            const bLines = new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.BoxGeometry(w, h, w)), mats.bgEdges);
            bLines.position.set(0, h / 2, 0);
            //bLines.scale.set(w, h, w);
            bGroup.add(bLines);

            if (hasTilt) {
                bMesh.rotation.x = tiltX;
                bMesh.rotation.z = tiltZ;
                bLines.rotation.x = tiltX;
                bLines.rotation.z = tiltZ;
            }

            bMesh.castShadow = true;
            bMesh.receiveShadow = true;

            // 5. 恢复废墟状态
            if (hasHistory) {
                const record = buildingHistory.get(uniqueId);
                bGroup.position.copy(record.pos);
                bGroup.quaternion.copy(record.rot);
                bGroup.scale.copy(record.scale);
                bGroup.userData.animState = 'collapsed';
                bGroup.userData.animProgress = 1.0;
            }

            scene.add(bGroup);
            objects.push(bGroup);
            buildingRegistry.set(uniqueId, bGroup);
            zoneBuildingIds.push(uniqueId);
        }

        zoneToBuildings.set(zone, zoneBuildingIds);
    }

    function createTextTexture(title, desc) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const width = 512, height = 512;
        canvas.width = width;
        canvas.height = height;
        ctx.fillStyle = 'rgba(100.0,100.0,100.0, 0.2)';
        ctx.fillRect(0, 0, width, height);
        ctx.strokeStyle = '#00ffff';
        ctx.lineWidth = 6;
        ctx.strokeRect(0, 0, width, height);
        ctx.textAlign = 'left';
        ctx.font = 'bold 100px Helvetica, Arial';
        ctx.fillStyle = '#ffffff';
        ctx.shadowColor = "#00ffff";
        ctx.shadowBlur = 3;
        ctx.fillText(title, 40, 130);
        ctx.shadowBlur = 0;
        ctx.beginPath();
        ctx.moveTo(40, 150);
        ctx.lineTo(width - 40, 150);
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#00ffff';
        ctx.stroke();
        ctx.font = 'normal 40px Helvetica, Arial';
        ctx.fillStyle = '#cccccc';
        const words = (desc || "").split(' ');
        let line = '', y = 220;
        for (let n = 0; n < words.length; n++) {
            if (ctx.measureText(line + words[n]).width > width - 80) {
                ctx.fillText(line, 40, y);
                line = words[n] + ' ';
                y += 50;
            } else {
                line += words[n] + ' ';
            }
        }
        ctx.fillText(line, 40, y);
        return new THREE.CanvasTexture(canvas);
    }

    function onWindowResize() {
        const dpr = Math.min(window.devicePixelRatio, config.maxPixelRatio);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        if (bloomComposer) {
            bloomComposer.setSize(window.innerWidth, window.innerHeight);
            bloomComposer.setPixelRatio(dpr);
        }
        if (finalComposer) {
            finalComposer.setSize(window.innerWidth, window.innerHeight);
            finalComposer.setPixelRatio(dpr);
        }
    }

    function onDocumentMouseWheel(event) {
        event.preventDefault();
        targetCameraHeight = Math.max(50, Math.min(400, targetCameraHeight + event.deltaY * 0.5));
    }

    function onMouseDown(event) {
        isDragging = true;
        previousMouseY = event.clientY;
        previousMouseX = event.clientX;
        document.body.classList.add('grabbing');
    }

    function onMouseUp() {
        isDragging = false;
        document.body.classList.remove('grabbing');
    }

    function onMouseClick(event) {
        if (isDragging) return;
        if (hoveredObject) {
            const info = hoveredObject.userData.storyData;
            const nodeId = hoveredObject.userData.nodeId;
            if (nodeAnimRegistry[nodeId] && nodeAnimRegistry[nodeId].status !== 'unlocked') return;
            if (info.url && info.url !== "") window.open(info.url, '_blank');
            else alert(`Selected: ${info.title ? info.title : "Node"}\n\n${info.desc ? info.desc : ""}\n(No URL linked)`);
        }
    }

    function checkIntersection() {
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(interactiveObjects);
        if (intersects.length > 0) {
            const object = intersects[0].object;
            const nodeId = object.userData.nodeId || object.parent.userData.nodeId;
            if (nodeId && nodeAnimRegistry[nodeId] && nodeAnimRegistry[nodeId].status !== 'unlocked') {
                if (hoveredObject) {
                    restoreObject(hoveredObject);
                    hoveredObject = null;
                }
                return;
            }
            if (hoveredObject !== object) {
                if (hoveredObject) restoreObject(hoveredObject);
                hoveredObject = object;
                highlightObject(hoveredObject);
            }
        } else {
            if (hoveredObject) {
                restoreObject(hoveredObject);
                hoveredObject = null;
            }
        }
    }

    function highlightObject(mesh) {
        document.body.classList.add('pointer');
        const targetScale = mesh.userData.originScale.clone().multiplyScalar(1.2);
        mesh.scale.copy(targetScale);
    }

    function restoreObject(mesh) {
        document.body.classList.remove('pointer');
        mesh.scale.copy(mesh.userData.originScale);
    }

    function onMouseMove(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        if (!isDragging) {
            checkIntersection();
            return;
        }
        const deltaX = event.clientX - previousMouseX;
        const deltaY = event.clientY - previousMouseY;
        const scrollInput = (deltaX + deltaY);
        targetScrollPos += scrollInput * 0.35;
        const panInput = (deltaX - deltaY);
        targetCameraOffsetX -= panInput * 0.35;
        previousMouseX = event.clientX;
        previousMouseY = event.clientY;
    }

    function updateParticles(delta) {
        const t = globalUniforms.time.value;
        allParticles.forEach(pMesh => {
            if (pMesh.parent.visible === false) return;
            if (pMesh.userData.type === 'flow') {
                const data = pMesh.userData.flowData;
                data.progress = (data.progress + data.speed * TIME_SCALE * delta) % 1;
                const wobble = Math.sin(t * data.wobbleSpeed + data.phase) * data.wobbleAmp;
                pMesh.position.copy(data.start).add(data.endVec.clone().multiplyScalar(data.progress)).add(data.sideVec.clone().multiplyScalar((1.2 + wobble) * data.sideModifier));
            }
        });
    }

    function updateBuildingAnimations(currentZone, delta) {
        const t = globalUniforms.time.value;

        buildingRegistry.forEach((building, buildingId) => {
            const userData = building.userData;
            const zoneDist = Math.abs(userData.zone - currentZone);
            const shouldBeVisible = zoneDist <= VISIBLE_ZONE_RADIUS;

            // 计算正常的上下悬浮 (只对未倒塌的建筑生效)
            let floatOffset = 0;
            const isAlive = (userData.animState !== 'collapsing' && userData.animState !== 'collapsed');
            if (userData.animSpeed && isAlive) {
                floatOffset = Math.sin(t * userData.animSpeed + userData.animPhase) * userData.animAmp;
            }

            if (userData.animState === 'appearing') {
                // 如果建筑重生，重置所有变换
                if (userData.animProgress === 0) {
                    building.rotation.set(0, 0, 0);
                    building.scale.set(1, 1, 1);
                }
                const increment = 0.02 * BUILDING_ANIMATION_SPEED * TIME_SCALE * delta;
                userData.animProgress += increment;
                if (userData.animProgress >= 1.0) {
                    userData.animProgress = 1.0;
                    userData.animState = 'visible';
                }
                const k = userData.animProgress;
                const eased = 1 - Math.pow(1 - k, 3);
                const disappearOffset = userData.type === 'top' ? 300 : -300;
                building.position.y = userData.baseY + (disappearOffset * (1 - eased)) + (floatOffset * eased);

            } else if (userData.animState === 'visible') {
                if (!shouldBeVisible) {
                    userData.animState = 'disappearing'; // 离远了彻底消失
                    userData.animProgress = 0;
                } else {
                    building.position.y = userData.baseY + floatOffset;
                }

            } else if (userData.animState === 'collapsing') {

                const collapseSpeed = 0.008 * TIME_SCALE * delta;
                userData.animProgress += collapseSpeed;

                if (userData.animProgress >= 1.0) {
                    userData.animProgress = 1.0;
                    userData.animState = 'collapsed';

                    // --- [核心修改] 倒塌完成，记录状态 ---
                    // 记录此时 Group 的世界坐标、旋转和缩放
                    buildingHistory.set(userData.buildingId, {
                        pos: building.position.clone(),
                        rot: building.quaternion.clone(), // 存四元数
                        scale: building.scale.clone()
                    });
                }

                const p = userData.animProgress;
                const easeDrop = p * p;
                const easeRot = p * p;

                if (userData.collapseData) {
                    building.rotation.set(0, 0, 0);
                    const curAngle = userData.collapseData.targetAngle * easeRot;
                    building.rotateOnWorldAxis(userData.collapseData.axis, curAngle);
                }

                const sink = userData.collapseData.sinkAmount * easeDrop * 0.2;
                building.position.y = (userData.baseY + floatOffset) - sink;

                const jitter = Math.sin(p * 25) * 0.01 * (1 - p);
                building.scale.set(1 + jitter, 1 - p * 0.05, 1 + jitter);

            } else if (userData.animState === 'collapsed') {
                // 【新逻辑】已倒塌状态
                // 保持静止，不跟随 floatOffset 浮动
                // 如果离得太远了，还是要删除，节省性能
                if (!shouldBeVisible) {
                    userData.animState = 'disappearing';
                    userData.animProgress = 0;
                }
                // 这里不需要写代码，因为位置和旋转已经保留在上一帧的状态了

            } else if (userData.animState === 'disappearing') {
                // 彻底消失（用于离相机太远时的清理）
                const increment = 0.02 * BUILDING_ANIMATION_SPEED * TIME_SCALE * delta;
                userData.animProgress += increment;
                if (userData.animProgress >= 1.0) {
                    userData.animProgress = 1.0;
                    userData.animState = 'hidden';
                }

                // 这里我们简单处理：如果是 collapsed 之后的 disappearing，就直接缩小
                const k = userData.animProgress;
                if (userData.type === 'bottom') {
                    building.scale.setScalar(1 - k); // 简单缩小至无
                } else {
                    const eased = k * k * k;
                    const disappearOffset = 300;
                    building.position.y = userData.baseY + (disappearOffset * eased) + (floatOffset * (1 - eased));
                }
            }
        });
    }

    // [新增] 专门负责更新闪电几何体形状的函数
    function updateLightningEffects(delta) {
        edgeAnimRegistry.forEach(edge => {
            // 如果线条完全隐藏，则不渲染
            if (edge.status === 'hidden') {
                edge.lightningLines.forEach(l => l.visible = false);
                return;
            }

            // 计算当前电流的终点位置（如果是 growing 状态，终点会移动）
            const currentEnd = edge.targetVec.clone().multiplyScalar(edge.progress);

            // 更新每一根闪电束
            edge.lightningLines.forEach((line, strandIndex) => {
                line.visible = true;
                const positions = line.geometry.attributes.position.array;

                // 为了让闪电看起来在两点之间，我们需要插值
                // 简单的线性插值 + 随机抖动
                for (let i = 0; i <= LIGHTNING_SEGMENTS; i++) {
                    const pct = i / LIGHTNING_SEGMENTS;

                    // 基础线性坐标
                    const baseX = currentEnd.x * pct;
                    const baseY = currentEnd.y * pct;
                    const baseZ = currentEnd.z * pct;

                    // 计算抖动包络线 (两端不动，中间抖动幅度最大)
                    // Math.sin(pct * PI) 在 0 和 1 时为 0，在 0.5 时为 1
                    const envelope = Math.sin(pct * Math.PI);

                    // 核心线(strandIndex=0)抖动小，外围线抖动大
                    const ampBase = (strandIndex === 0) ? 5.0 : 2.5;
                    const amp = ampBase * envelope;

                    // 每一帧都重新随机，产生电流闪烁感
                    const jitterX = (Math.random() - 0.5) * amp;
                    const jitterY = (Math.random() - 0.5) * amp;
                    const jitterZ = (Math.random() - 0.5) * amp;

                    positions[i * 3] = baseX + jitterX;
                    positions[i * 3 + 1] = baseY + jitterY;
                    positions[i * 3 + 2] = baseZ + jitterZ;
                }

                line.geometry.attributes.position.needsUpdate = true;
            });
        });
    }

    function updateUnlockAnimations(delta) {
        const edgeSpeed = 0.02 * TIME_SCALE * delta;
        const nodeSpeed = 0.05 * TIME_SCALE * delta;

        // [修改] 此处只负责更新逻辑状态和进度，视觉更新交给 updateLightningEffects
        edgeAnimRegistry.forEach(edge => {
            if (edge.status === 'growing') {
                edge.progress += edgeSpeed;
                if (edge.progress >= 1.0) {
                    edge.progress = 1.0;
                    edge.status = 'shown';
                    edge.particleGroup.visible = true;
                    const childNode = nodeAnimRegistry[edge.childId];
                    if (childNode && childNode.status === 'locked') childNode.status = 'popping';
                }
            }
        });

        for (const nodeId in nodeAnimRegistry) {
            const data = nodeAnimRegistry[nodeId];
            if (data.status === 'popping') {
                data.scaleProgress += nodeSpeed;
                let scale = data.scaleProgress;
                const backScale = 1 + 2.70158 * Math.pow(scale - 1, 3) + 1.70158 * Math.pow(scale - 1, 2);
                if (data.scaleProgress >= 1.0) {
                    data.scaleProgress = 1.0;
                    data.status = 'unlocked';
                    scale = 1.0;
                } else {
                    scale = scale > 1 ? backScale : scale;
                }
                data.group.scale.set(scale, scale, scale);
            }
        }
    }

    function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        globalUniforms.time.value += delta * 1.2;
        updateParticles(delta);
        updateUnlockAnimations(delta);
        updateLightningEffects(delta); // 确保你有上一步加的闪电特效

        if (cloudMesh) {
            cloudMesh.position.x = camera.position.x;
            cloudMesh.position.z = camera.position.z;
        }
        const dampingBase = 0.95;
        const safeDelta = Math.min(delta, 0.1);
        const dampingFactor = 1.0 - Math.pow(dampingBase, safeDelta * 60);
        scrollPos += (targetScrollPos - scrollPos) * dampingFactor;
        cameraOffsetX += (targetCameraOffsetX - cameraOffsetX) * dampingFactor;
        cameraHeight += (targetCameraHeight - cameraHeight) * dampingFactor;

        const currentFocusZ = -scrollPos;
        const currentZone = Math.floor(currentFocusZ / BUILDING_ZONE_SIZE);
        const buildingRenderRange = 500;
        const minBuildingZ = currentFocusZ - buildingRenderRange;
        const maxBuildingZ = currentFocusZ + buildingRenderRange;
        const minZone = Math.floor(minBuildingZ / BUILDING_ZONE_SIZE);
        const maxZone = Math.floor(maxBuildingZ / BUILDING_ZONE_SIZE);

        for (let zone = minZone; zone <= maxZone; zone++) {
            if (!generatedBuildingZones.has(zone)) {
                createRandomBuildings(zone);
                generatedBuildingZones.add(zone);
            }
        }

        updateBuildingAnimations(currentZone, delta);

        const baseCenterX = 0;
        const finalCamX = baseCenterX + cameraOffsetX - 100 * (cameraHeight / 100);
        camera.position.set(finalCamX, cameraHeight, currentFocusZ + 120 * (cameraHeight / 100));
        camera.lookAt(baseCenterX + cameraOffsetX, 0, currentFocusZ);

        const light = scene.getObjectByName("mainLight");
        if (light) {
            light.position.set(baseCenterX + cameraOffsetX + 200, 1500, currentFocusZ + 200);
            light.target.position.set(baseCenterX + cameraOffsetX, 0, currentFocusZ);
            light.target.updateMatrixWorld();
        }

        // --- 清理逻辑修改 ---
        for (let i = objects.length - 1; i >= 0; i--) {
            const obj = objects[i];
            const isMainNode = (obj.userData.type === 'mainNode');

            if (!isMainNode && obj.userData.buildingId !== undefined) {
                const buildingId = obj.userData.buildingId;
                const isOutOfRange = (obj.position.z < minBuildingZ - 200 || obj.position.z > maxBuildingZ + 200);

                // 【修改点】只要是 "hidden" 或者 "离得太远的 collapsed/disappearing" 都要删除
                const isDead = (obj.userData.animState === 'hidden');
                // 如果是 collapsed 状态，且严重超出范围，也强制清理
                const isLostRuins = (obj.userData.animState === 'collapsed' && isOutOfRange);

                if ((isDead || isLostRuins) && isOutOfRange) {
                    obj.traverse((child) => {
                        if (child.userData && child.userData.isInteractive) {
                            const idx = interactiveObjects.indexOf(child);
                            if (idx > -1) interactiveObjects.splice(idx, 1);
                            if (hoveredObject === child) {
                                hoveredObject = null;
                                document.body.classList.remove('pointer');
                            }
                        }
                    });
                    scene.remove(obj);
                    disposeHierarchy(obj);
                    objects.splice(i, 1);
                    buildingRegistry.delete(buildingId);
                    if (obj.userData.zone !== undefined) generatedBuildingZones.delete(obj.userData.zone);
                }
            }
        }

        if (bloomComposer) {
            if (cloudMesh) cloudMesh.visible = false;
            scene.background = new THREE.Color(0x000000);
            camera.layers.set(BLOOM_LAYER);
            bloomComposer.render();
            if (cloudMesh) cloudMesh.visible = true;
            scene.background = new THREE.Color(config.bgColor);
            camera.layers.set(0);
            finalComposer.render();
        }
    }

    // 配置更新逻辑保持不变
    window.addEventListener('message', function (event) {
        const data = event.data;
        if (data.type === 'updateConfig') {
            const key = data.key;
            const value = data.value;
            if (typeof value === 'string' && value.startsWith('#')) config[key] = parseInt(value.replace('#', '0x'), 16);
            else config[key] = value;
            updateSceneFromConfig(key, config[key]);
        } else if (data.type === 'requestConfig') {
            const exportConfig = {};
            for (let k in config) {
                if (k.toLowerCase().includes('color')) exportConfig[k] = '#' + config[k].toString(16).padStart(6, '0');
                else exportConfig[k] = config[k];
            }
            window.parent.postMessage({type: 'configLoaded', config: exportConfig}, '*');
        }
    });

    function updateSceneFromConfig(key, val) {
        const colorObj = new THREE.Color(val);
        switch (key) {
            case 'bgColor':
                scene.background = colorObj;
                break;
            case 'fogColor':
                globalUniforms.fogColor.value.copy(colorObj);
                break;
            case 'cloudBaseColor':
                globalUniforms.cloudBaseColor.value.copy(colorObj);
                break;
            case 'cloudHighlightColor':
                globalUniforms.cloudHighlightColor.value.copy(colorObj);
                break;
            case 'mainBlockColor':
                if (mats.mainBox) mats.mainBox.color.copy(colorObj);
                break;
            case 'bgBlockColor':
                if (mats.bgBox) mats.bgBox.color.copy(colorObj);
                break;
            case 'mainEdgeColor':
                if (mats.mainEdges) mats.mainEdges.color.copy(colorObj);
                if (mats.line) mats.line.color.copy(colorObj);
                if (particleMat) particleMat.color.copy(colorObj);
                break;
            case 'dimEdgeColor':
                if (mats.dimEdges) mats.dimEdges.color.copy(colorObj);
                break;
            case 'heightFogDensity':
                updateMaterialUniforms('hFogDensity', val);
                break;
            case 'heightFogBase':
                updateMaterialUniforms('hFogBase', val);
                break;
        }
    }

    function updateMaterialUniforms(uniformName, value) {
        scene.traverse(obj => {
            if (obj.material) {
                const matList = Array.isArray(obj.material) ? obj.material : [obj.material];
                matList.forEach(m => {
                    if (m.userData && m.userData.shader && m.userData.shader.uniforms && m.userData.shader.uniforms[uniformName]) {
                        m.userData.shader.uniforms[uniformName].value = value;
                    }
                });
            }
        });
    }
</script>
</body>

</html>