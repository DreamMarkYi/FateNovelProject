<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Infinite Timeline - Fixed</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            cursor: grab;
            transition: background-color 0.5s ease;
        }

        body.mode-light {
            background-color: #f0f0f0;
            color: #333;
        }

        body.mode-neon {
            background-color: #050505;
            color: #fff;
        }

        body.grabbing {
            cursor: grabbing;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            z-index: 10;
            transition: all 0.5s ease;
        }

        /* 标题样式适配 */
        h1 {
            font-weight: 300;
            letter-spacing: 2px;
            margin: 0;
            text-transform: uppercase;
            font-size: 1.2rem;
            display: inline-block;
            padding-bottom: 5px;
            transition: all 0.5s;
        }

        body.mode-light h1 {
            border-bottom: 1px solid #333;
            color: #1a1a1a;
        }

        body.mode-neon h1 {
            border-bottom: 1px solid #00ffff;
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        body.mode-light #ui {
            color: #333;
        }

        body.mode-neon #ui {
            color: #fff;
            mix-blend-mode: difference;
        }

        p {
            font-size: 0.8rem;
            opacity: 0.8;
            margin-top: 5px;
        }

        /* 切换按钮样式 */
        #toggle-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            border: 1px solid;
            cursor: pointer;
            font-family: inherit;
            letter-spacing: 1px;
            text-transform: uppercase;
            background: transparent;
            z-index: 20;
            transition: all 0.3s;
            outline: none;
        }

        body.mode-light #toggle-btn {
            border-color: #333;
            color: #333;
        }

        body.mode-light #toggle-btn:hover {
            background: #333;
            color: #fff;
        }

        body.mode-neon #toggle-btn {
            border-color: #00ffff;
            color: #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
        }

        body.mode-neon #toggle-btn:hover {
            background: rgba(0, 255, 255, 0.1);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            letter-spacing: 5px;
            transition: opacity 0.5s;
            pointer-events: none;
        }

        body.mode-light .loading {
            color: #666;
        }

        body.mode-neon .loading {
            color: #00ffff;
            text-shadow: 0 0 15px #00ffff;
        }
    </style>
</head>

<body class="mode-light">

    <div id="ui">
        <h1 id="ui-title">CHRONO INFINITY</h1>
        <p id="ui-desc">Initializing...</p>
    </div>

    <button id="toggle-btn">SWITCH MODE</button>

    <div id="loading" class="loading">SYSTEM INITIALIZING...</div>
    <div id="canvas-container"></div>

    <!-- Three.js Core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- Post-Processing Dependencies -->
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/shaders/CopyShader.js"></script>
    <script
        src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script
        src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/postprocessing/ShaderPass.js"></script>
    <script
        src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <script>
        // --- 双模式配置参数 ---
        const MODES = {
            LIGHT: 'light',
            NEON: 'neon'
        };

        const config = {
            // 通用配置
            spacingZ: 40,
            renderRange: 45,
            laneCount: 5,
            laneDist: 350,

            // 性能优化配置
            maxPixelRatio: 2, // 限制最大像素比

            // 当前模式状态
            currentMode: MODES.LIGHT,

            // 模式特定配置 getter
            get bgColor() { return this.currentMode === MODES.LIGHT ? 0xf0f0f0 : 0x49647b; },
            get fogColor() { return this.currentMode === MODES.LIGHT ? 0xffffff : 0x49647b; },
            get heightFogDensity() { return this.currentMode === MODES.LIGHT ? 0.012 : 0.02; },
            get heightFogBase() { return this.currentMode === MODES.LIGHT ? -1.0 : -1.0; }, // 调整雾气基准高度

            // NEON模式下方块基础颜色调亮
            get blockColor() { return this.currentMode === MODES.LIGHT ? 0xffffff : 0x222222; },
            get lineColor() { return this.currentMode === MODES.LIGHT ? 0x333333 : 0x222222; },

            // 霓虹模式特有颜色
            mainEdgeColor: 0xffffff,
            dimEdgeColor: 0xffffff,

            get crossLinkChance() { return this.currentMode === MODES.LIGHT ? 0.15 : 0.15; },
            get textColor() { return this.currentMode === MODES.LIGHT ? '#1a1a1a' : '#ffffff'; },

            // UI 文本
            get uiTitle() { return this.currentMode === MODES.LIGHT ? "CHRONO INFINITY // DAY" : "NEON INFINITY // HIGH ENERGY"; },
            get uiDesc() { return this.currentMode === MODES.LIGHT ? "FIXED STORYLINE • CROSS-LINKS ACTIVE" : "STORY SCAN ACTIVE • ENERGY LEVEL MAXIMIZED"; }
        };

        const globalUniforms = {
            time: { value: 0 }
        };

        // --- 核心变量 ---
        let scene, camera, renderer, bloomComposer, finalComposer;
        let scrollPos = -50;
        let targetScrollPos = -50;
        let activeIndices = new Set();
        let cameraHeight = 100;
        let targetCameraHeight = 100;
        let isDragging = false;
        let previousMouseY = 0;
        let objects = [];

        // 材质 (动态生成)
        let mats = {};

        // --- 数据生成逻辑：主线配置 ---
        const TIMELINE_STORY = {
            // 核心节点
            2024: { title: "INIT: 创世纪", desc: "时间轴系统启动，虚拟空间构建完成。", lane: 2 },
            2023: { title: "ALPHA: 原型", desc: "首次进行数据流注入测试。", lane: 2 },
            2022: { title: "LINK: 连接", desc: "神经网络接口v1.0发布。", lane: 1 },
            2020: { title: "CRISIS: 停滞", desc: "全球数据大崩溃。", lane: 3 },
            2015: { title: "SEED: 萌芽", desc: "第一个AI意识碎片诞生。", lane: 2 },

            // 历史回溯
            2010: { title: "CLOUD: 云端", desc: "数据开始向天空迁移。", lane: 4 },
            2000: { title: "Y2K: 千年虫", desc: "旧时代的数字恐慌。", lane: 2 },
            1995: { title: "WEB: 浪潮", desc: "信息高速公路铺设完成。", lane: 1 },
            1984: { title: "DYSTOPIA", desc: "老大哥在看着你。", lane: 3 },
            1969: { title: "MOON: 登月", desc: "人类的一大步。", lane: 2 },

            // 未来预测
            2030: { title: "SINGULARITY", desc: "奇点临近，机器智能超越人类。", lane: 2 },
            2045: { title: "IMMORTAL", desc: "意识上传技术民用化。", lane: 0 },
            2050: { title: "MARS: 殖民", desc: "红色星球建立首个前哨站。", lane: 4 },
            2077: { title: "CYBERPUNK", desc: "高科技，低生活。", lane: 2 }
        };

        // 填充数据词库
        const FILLER_DATA = {
            prefixes: ["CACHE", "LOG", "DUMP", "SYNC", "NODE"],
            descs: [
                "Data stream stable.",
                "Background process.",
                "Memory block #404.",
                "Routine maintenance.",
                "Encrypted signal.",
                "Sector clear.",
                "Uploading...",
                "Ping: 4ms"
            ]
        };

        function init() {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(25, window.innerWidth / window.innerHeight, 10, 10000);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);

            const dpr = Math.min(window.devicePixelRatio, config.maxPixelRatio);
            renderer.setPixelRatio(dpr);

            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('wheel', onDocumentMouseWheel, { passive: false });
            document.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('mouseup', onMouseUp, false);
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('mouseleave', onMouseUp, false);

            document.getElementById('toggle-btn').addEventListener('click', toggleMode);

            setupSceneMode();

            document.getElementById('loading').style.opacity = 0;
            animate();
        }

        function toggleMode() {
            config.currentMode = (config.currentMode === MODES.LIGHT) ? MODES.NEON : MODES.LIGHT;
            const body = document.body;
            body.className = config.currentMode === MODES.LIGHT ? 'mode-light' : 'mode-neon';
            document.getElementById('toggle-btn').innerText = config.currentMode === MODES.LIGHT ? 'SWITCH TO NEON' : 'SWITCH TO LIGHT';
            setupSceneMode();
        }

        function setupSceneMode() {
            clearScene();
            document.getElementById('ui-title').innerText = config.uiTitle;
            document.getElementById('ui-desc').innerHTML = config.uiDesc + "<br>滚轮拉远查看全貌 • 拖拽移动";
            scene.background = new THREE.Color(config.bgColor);
            scene.fog = new THREE.FogExp2(config.fogColor, 0.0006);

            initMaterials();
            setupLights();
            setupPostProcessing();
            activeIndices.clear();
        }

        function clearScene() {
            for (let i = objects.length - 1; i >= 0; i--) {
                const obj = objects[i];
                scene.remove(obj);
                disposeHierarchy(obj);
            }
            objects = [];

            const oldLights = scene.children.filter(c => c.isLight || c.type === 'GridHelper');
            oldLights.forEach(l => {
                scene.remove(l);
                if (l.dispose) l.dispose();
            });
        }

        function disposeHierarchy(node) {
            node.traverse((child) => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(m => {
                            if (m.map) m.map.dispose();
                            m.dispose();
                        });
                    } else {
                        if (child.material.map) child.material.map.dispose();
                        child.material.dispose();
                    }
                }
            });
        }

        // 简化后的高度雾 Shader 逻辑：不再依赖水面波浪
        function getHeightFogShaderLogic(useAlphaFade = false) {
            return (shader) => {
                shader.uniforms.hFogColor = { value: new THREE.Color(config.fogColor) };
                shader.uniforms.hFogDensity = { value: config.heightFogDensity };
                shader.uniforms.hFogBase = { value: config.heightFogBase };

                shader.vertexShader = shader.vertexShader.replace(
                    `#include <common>`,
                    `#include <common>
             varying vec3 vWorldPosition;`
                );
                shader.vertexShader = shader.vertexShader.replace(
                    `#include <begin_vertex>`,
                    `#include <begin_vertex>
             vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;`
                );

                shader.fragmentShader = shader.fragmentShader.replace(
                    `#include <common>`,
                    `#include <common>
             uniform vec3 hFogColor;
             uniform float hFogDensity;
             uniform float hFogBase;
             varying vec3 vWorldPosition;`
                );

                shader.fragmentShader = shader.fragmentShader.replace(
                    `#include <fog_fragment>`,
                    `
            // 简单的指数高度雾计算
            float heightFactor = 0.0;
            // 当位置低于雾平面时，计算雾浓度
            if (vWorldPosition.y < hFogBase) {
                float dist = hFogBase - vWorldPosition.y;
                heightFactor = 1.0 - exp(-dist * hFogDensity);
            }
            heightFactor = clamp(heightFactor, 0.0, 1.0);

            // 将高度雾颜色混合到物体颜色中
            gl_FragColor.rgb = mix(gl_FragColor.rgb, hFogColor, heightFactor);

            ${useAlphaFade ? 'gl_FragColor.a *= (1.0 - heightFactor);' : ''}

            #include <fog_fragment>
            `
                );
            };
        }

        function initMaterials() {
            const shaderLogic = getHeightFogShaderLogic(false);
            const shaderLogicFade = getHeightFogShaderLogic(true);
            mats = {};

            const boxParams = { color: config.blockColor };
            if (config.currentMode === MODES.NEON) {
                boxParams.emissive = 0x002244;
                boxParams.emissiveIntensity = 0;
            }

            mats.box = new THREE.MeshLambertMaterial(boxParams);
            mats.box.onBeforeCompile = shaderLogic;

            mats.line = new THREE.LineBasicMaterial({
                color: config.lineColor,
                transparent: true,
                opacity: config.currentMode === MODES.NEON ? 0.3 : 0.5
            });
            mats.line.onBeforeCompile = shaderLogicFade;

            if (config.currentMode === MODES.LIGHT) {
                mats.edges = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
                mats.edges.onBeforeCompile = shaderLogic;
                mats.branchEdges = mats.edges;
                mats.branchConnectors = mats.line;
            } else {
                mats.glowEdges = new THREE.LineBasicMaterial({ color: config.mainEdgeColor, linewidth: 10, transparent: true });
                mats.glowEdges.onBeforeCompile = shaderLogicFade;
                mats.dimEdges = new THREE.LineBasicMaterial({ color: config.dimEdgeColor, linewidth: 10 });
                mats.dimEdges.onBeforeCompile = shaderLogicFade;
                mats.branchEdges = mats.glowEdges;
                mats.branchConnectors = mats.glowEdges;
                mats.bgEdges = mats.dimEdges;
            }
            const personColor = config.currentMode === MODES.LIGHT ? 0x333333 : 0x00aaaa;
            mats.person = new THREE.MeshBasicMaterial({ color: personColor });
            mats.person.onBeforeCompile = shaderLogic;

            if (config.currentMode === MODES.NEON) {
                mats.flowingLight = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.8
                });
            }
        }

        function setupLights() {
            const ambientIntensity = config.currentMode === MODES.LIGHT ? 0.7 : 3.0;
            const ambientColor = config.currentMode === MODES.LIGHT ? 0xffffff : 0xa7c5de;
            const ambientLight = new THREE.AmbientLight(ambientColor, ambientIntensity);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, config.currentMode === MODES.LIGHT ? 0.6 : 6.0);
            dirLight.name = "mainLight";
            if (config.currentMode === MODES.NEON) {
                dirLight.position.set(100, 200, 100);
                dirLight.color.setHSL(0.6, 0.2, 1.0);
            }
            dirLight.castShadow = true;

            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;

            const shadowRange = config.laneCount * config.laneDist + 1000;
            dirLight.shadow.camera.left = -1000;
            dirLight.shadow.camera.right = shadowRange;
            dirLight.shadow.camera.top = 1000;
            dirLight.shadow.camera.bottom = -1000;
            dirLight.shadow.camera.near = 0.1;
            dirLight.shadow.camera.far = 2000;
            scene.add(dirLight);
        }

        function setupPostProcessing() {
            if (config.currentMode === MODES.NEON) {
                const dpr = Math.min(window.devicePixelRatio, config.maxPixelRatio);
                const renderScene = new THREE.RenderPass(scene, camera);

                const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth * dpr, window.innerHeight * dpr), 1.5, 0.4, 0.85);
                bloomPass.threshold = 0;
                bloomPass.strength = 1.5;
                bloomPass.radius = 0.5;

                bloomComposer = new THREE.EffectComposer(renderer);
                bloomComposer.renderToScreen = false;
                bloomComposer.setPixelRatio(dpr);
                bloomComposer.addPass(renderScene);
                bloomComposer.addPass(bloomPass);

                const finalPass = new THREE.ShaderPass(
                    new THREE.ShaderMaterial({
                        uniforms: {
                            baseTexture: { value: null },
                            bloomTexture: { value: bloomComposer.renderTarget2.texture }
                        },
                        vertexShader: `
                            varying vec2 vUv;
                            void main() {
                                vUv = uv;
                                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                            }
                        `,
                        fragmentShader: `
                            uniform sampler2D baseTexture;
                            uniform sampler2D bloomTexture;
                            varying vec2 vUv;
                            void main() {
                                gl_FragColor = ( texture2D( baseTexture, vUv )+ vec4( 1.0 ) * texture2D( bloomTexture, vUv ) );
                            }
                        `,
                        defines: {}
                    }), "baseTexture"
                );
                finalPass.needsSwap = true;

                finalComposer = new THREE.EffectComposer(renderer);
                finalComposer.setPixelRatio(dpr);
                finalComposer.addPass(renderScene);
                finalComposer.addPass(finalPass);
            } else {
                bloomComposer = null;
                finalComposer = null;
            }
        }

        function generateDataForIndex(i, laneIdx) {
            const year = 2024 - i;
            if (TIMELINE_STORY.hasOwnProperty(year)) {
                const story = TIMELINE_STORY[year];
                const targetLane = story.lane !== undefined ? story.lane : 2;
                if (laneIdx === targetLane) {
                    return {
                        year: year.toString(),
                        title: story.title,
                        desc: story.desc,
                        isStory: true
                    };
                }
            }
            const seed = Math.sin(year * 9999 + laneIdx * 777) * 43758.5453;
            const randIdx = Math.floor(Math.abs(seed) * 1000);
            const prefix = FILLER_DATA.prefixes[randIdx % FILLER_DATA.prefixes.length];
            const desc = FILLER_DATA.descs[randIdx % FILLER_DATA.descs.length];
            const laneNames = ["ALPHA", "BETA", "GAMMA", "DELTA", "EPSILON", "ZETA", "ETA", "THETA"];
            const laneName = laneNames[laneIdx % laneNames.length];
            return {
                year: year.toString(),
                title: `${prefix} ${laneName}-${Math.abs(i) % 99}`,
                desc: desc,
                isStory: false
            };
        }

        function createRow(index) {
            const laneGroups = [];
            for (let l = 0; l < config.laneCount; l++) laneGroups.push(createLane(index, l));
            for (let l = 0; l < config.laneCount - 1; l++) {
                const linkSeed = Math.sin(index * 999 + l * 777) * 43758.5453;
                if (((linkSeed - Math.floor(linkSeed)) < config.crossLinkChance)) {
                    const groupA = laneGroups[l], groupB = laneGroups[l + 1];
                    const posA = groupA.position, posB = groupB.position;
                    const endLocal = new THREE.Vector3(posB.x - posA.x, posB.y - posA.y, posB.z - posA.z);
                    const linkLine = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), endLocal]), mats.line);
                    linkLine.userData = { bloom: true };
                    groupA.add(linkLine);
                    const marker = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), mats.box);
                    marker.position.copy(endLocal.clone().multiplyScalar(0.5));
                    groupA.add(marker);

                }
            }
        }

        function createLane(index, laneIdx) {
            const boxGeo = new THREE.BoxGeometry(1, 1, 1);
            const personGeo = new THREE.ConeGeometry(0.15, 0.8, 8);

            const data = generateDataForIndex(index, laneIdx);

            const seed = Math.sin(index * 12.9898 + (laneIdx * 999.99)) * 43758.5453;
            const pseudoRand = (offset) => (Math.sin(seed + offset) * 10000) % 1;
            const zPos = -index * config.spacingZ;
            const laneOffsetX = laneIdx * config.laneDist;
            const group = new THREE.Group();
            const xPos = laneOffsetX + pseudoRand(1) * 20;
            const yPos = pseudoRand(2) * 10;
            group.position.set(xPos, yPos, zPos);
            group.userData = { baseY: yPos, type: 'main', index: index, lane: laneIdx };


            const nextIndex = index + 1;
            const nextSeed = Math.sin(nextIndex * 12.9898 + (laneIdx * 999.99)) * 43758.5453;
            const nextPseudoRand = (offset) => (Math.sin(nextSeed + offset) * 10000) % 1;
            const nextXPos = laneOffsetX + nextPseudoRand(1) * 20;
            const nextYPos = nextPseudoRand(2) * 10;
            const nextZPos = -nextIndex * config.spacingZ;
            const lineEndLocal = new THREE.Vector3(nextXPos - xPos, nextYPos - yPos, nextZPos - zPos);
            const mainLine = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), lineEndLocal]), mats.line);
            mainLine.userData = { bloom: true };
            group.add(mainLine);

            const isStoryNode = data.isStory;
            const scaleMult = isStoryNode ? 4 : 4;

            const mainSx = (4 + Math.abs(pseudoRand(3)) * 4) * scaleMult;
            const mainSy = (1 + Math.abs(pseudoRand(4)) * 2) * scaleMult * 0.5;
            const mainSz = (4 + Math.abs(pseudoRand(5)) * 4) * scaleMult;

            const platform = new THREE.Mesh(boxGeo, mats.box);
            platform.scale.set(mainSx, mainSy, mainSz);
            platform.castShadow = true; platform.receiveShadow = true;

            const mainEdgesMat = (config.currentMode === MODES.NEON) ? mats.glowEdges : mats.edges;
            // --- 修复开始 ---
            // 原问题：使用了 BoxGeometry(mainSx, mainSy, mainSz)，导致作为子对象添加时被双重缩放。
            // 修复：使用标准的 boxGeo (1x1x1)，继承 platform 父对象的 scale。
            const mainEdges = new THREE.LineSegments(new THREE.EdgesGeometry(boxGeo), mainEdgesMat);
            mainEdges.userData = { bloom: true };
            platform.add(mainEdges);
            // --- 修复结束 ---

            group.add(platform);

            if (Math.abs(pseudoRand(10)) > 0.6) {
                const branchDir = pseudoRand(11) > 0 ? 1 : -1;
                const segments = 2 + Math.floor(Math.abs(pseudoRand(12)) * 3);
                let cX = (mainSx / 2) * branchDir, cY = 0, cZ = 0;
                for (let s = 0; s < segments; s++) {
                    const nX = cX + (25 + Math.abs(pseudoRand(20 + s)) * 35) * branchDir;
                    const nY = cY + (pseudoRand(14 + s) - 0.5) * 30;
                    const nZ = cZ + (pseudoRand(19 + s) - 0.5) * 30;
                    const branchConn = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(cX, cY, cZ), new THREE.Vector3(nX, nY, nZ)]), mats.branchConnectors);
                    branchConn.userData = { bloom: true };
                    group.add(branchConn);

                    const bSx = 3 + Math.abs(pseudoRand(15 + s)) * 10;
                    const bSy = 1 + Math.abs(pseudoRand(16 + s));
                    const bSz = 3 + Math.abs(pseudoRand(17 + s)) * 10;
                    const bEdgeLines = new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.BoxGeometry(bSx, bSy, bSz)), mats.branchEdges);
                    bEdgeLines.position.set(nX, nY, nZ);
                    bEdgeLines.userData = { bloom: true };
                    group.add(bEdgeLines);

                    const bLineHeight = 8 + Math.abs(pseudoRand(18 + s)) * 8;
                    const branchVert = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(nX, nY, nZ), new THREE.Vector3(nX, nY + bLineHeight, nZ)]), mats.branchConnectors);
                    branchVert.userData = { bloom: true };
                    group.add(branchVert);

                    const bPanelMat = new THREE.MeshBasicMaterial({ map: createTextTexture(data.year, "NODE " + s, "Sub-branch"), side: THREE.DoubleSide, transparent: true, blending: config.currentMode === MODES.NEON ? THREE.AdditiveBlending : THREE.NormalBlending });
                    bPanelMat.onBeforeCompile = getHeightFogShaderLogic();
                    const bPanel = new THREE.Mesh(new THREE.PlaneGeometry(6, 6), bPanelMat);
                    bPanel.position.set(nX + 4, nY + bLineHeight, nZ);
                    bPanel.rotation.y = -Math.PI / 4;
                    group.add(bPanel);

                    cX = nX; cY = nY; cZ = nZ;
                }
            }

            const lineHeight = 10 + Math.abs(pseudoRand(6)) * 10;
            const panelLineMat = (config.currentMode === MODES.NEON) ? mats.glowEdges : mats.line;
            const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, lineHeight, 0)]), panelLineMat);
            line.position.set(mainSx / 2 - 0.5, mainSy / 2, mainSz / 2 - 0.5);
            line.userData = { bloom: true };
            group.add(line);

            const panelMat = new THREE.MeshBasicMaterial({ map: createTextTexture(data.year, data.title, data.desc), side: THREE.DoubleSide, transparent: true, depthWrite: false, blending: config.currentMode === MODES.NEON ? THREE.AdditiveBlending : THREE.NormalBlending });
            panelMat.onBeforeCompile = getHeightFogShaderLogic();
            const panel = new THREE.Mesh(new THREE.PlaneGeometry(8, 8), panelMat);
            panel.position.set(mainSx / 2 - 0.5 + 4, mainSy / 2 + lineHeight, mainSz / 2 - 0.5);
            panel.rotation.y = -Math.PI / 4;
            group.add(panel);

            const person = new THREE.Mesh(personGeo, mats.person);
            person.position.set(0, mainSy / 2 + 0.4, 0);
            group.add(person);



            scene.add(group); objects.push(group);

            const bottomCount = 2 + Math.floor(Math.abs(pseudoRand(7)) * 4);
            for (let k = 0; k < bottomCount; k++) {
                const bGroup = new THREE.Group();
                const bZPos = zPos + pseudoRand(k * 10) * 120;
                let bXOffset = (Math.floor(Math.abs(pseudoRand(k * 123)) * 3) === 1) ? (config.laneDist / 2 + pseudoRand(k * 30) * 100) : (Math.floor(Math.abs(pseudoRand(k * 123)) * 3) === 2 ? (-config.laneDist / 2 + pseudoRand(k * 40) * 100) : (pseudoRand(k * 20) * 80 + (pseudoRand(k * 20) * 80 > 0 ? 25 : -25)));
                const bYBase = -100 - Math.abs(pseudoRand(k * 30)) * 250;
                bGroup.position.set(laneOffsetX + bXOffset, bYBase, bZPos);
                bGroup.userData = { baseY: bYBase, type: 'bottom', index: index, lane: laneIdx };

                const floors = 1 + Math.floor(Math.abs(pseudoRand(k * 40)) * 6);
                let cY = 0;
                const baseW = 15 + Math.abs(pseudoRand(k * 50)) * 25, baseD = 15 + Math.abs(pseudoRand(k * 60)) * 25;
                for (let f = 0; f < floors; f++) {
                    const h = 25 + Math.abs(pseudoRand(k * 70 + f)) * 45;
                    const taper = 1.0 - (f * 0.08);
                    const w = baseW * taper, d = baseD * taper;
                    const bMesh = new THREE.Mesh(boxGeo, mats.box);
                    bMesh.scale.set(w, h, d); bMesh.position.set(0, cY + h / 2, 0); bMesh.castShadow = true; bMesh.receiveShadow = true;
                    bGroup.add(bMesh);
                    const bgEdgeMat = (config.currentMode === MODES.NEON) ? mats.bgEdges : mats.edges;
                    const bLines = new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.BoxGeometry(w, h, d)), bgEdgeMat);
                    bLines.position.set(0, cY + h / 2, 0); bGroup.add(bLines);
                    bLines.userData = { bloom: true };
                    cY += h;
                }
                scene.add(bGroup); objects.push(bGroup);
            }

            const topCount = 1 + Math.floor(Math.abs(pseudoRand(50)));
            for (let k = 0; k < topCount; k++) {
                const tGroup = new THREE.Group();
                const tZPos = zPos + pseudoRand(k * 15) * 120;
                let tXOffset = pseudoRand(k * 25) * 240; if (Math.abs(tXOffset) < 30) tXOffset += (tXOffset > 0 ? 30 : -30);
                const tYBase = 400 + Math.abs(pseudoRand(k * 35)) * 300;
                tGroup.position.set(laneOffsetX + tXOffset, tYBase, tZPos);
                tGroup.userData = { baseY: tYBase, type: 'top', index: index, lane: laneIdx };

                const floors = 2 + Math.floor(Math.abs(pseudoRand(k * 45)) * 4);
                let cY = 0;
                const baseW = 15 + Math.abs(pseudoRand(k * 55)) * 25, baseD = 15 + Math.abs(pseudoRand(k * 65)) * 25;
                for (let f = 0; f < floors; f++) {
                    const h = 50 + Math.abs(pseudoRand(k * 75 + f)) * 40;
                    const taper = 1.0 - (f * 0.05);
                    const w = baseW * taper, d = baseD * taper;
                    const tMesh = new THREE.Mesh(boxGeo, mats.box);
                    tMesh.scale.set(w, h, d); tMesh.position.set(0, cY - h / 2, 0); tMesh.castShadow = true; tMesh.receiveShadow = true;
                    tGroup.add(tMesh);
                    const bgEdgeMat = (config.currentMode === MODES.NEON) ? mats.bgEdges : mats.edges;
                    const tLines = new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.BoxGeometry(w, h, d)), bgEdgeMat);
                    tLines.position.set(0, cY - h / 2, 0);
                    tLines.userData = { bloom: true };
                    tGroup.add(tLines);
                    cY -= h;
                }
                scene.add(tGroup); objects.push(tGroup);
            }

            return group;
        }

        function createTextTexture(year, title, desc) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const width = 512;
            const height = 512;
            canvas.width = width;
            canvas.height = height;

            if (config.currentMode === MODES.LIGHT) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillRect(0, 0, width, height);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 4;
                ctx.strokeRect(0, 0, width, height);
                ctx.fillStyle = config.textColor;
            } else {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                ctx.fillRect(0, 0, width, height);
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 6;
                ctx.strokeRect(0, 0, width, height);
                ctx.fillStyle = config.textColor;
                ctx.shadowColor = "#00ffff";
                ctx.shadowBlur = 10;
            }

            ctx.textAlign = 'left';
            ctx.font = 'bold 120px Helvetica, Arial';
            ctx.fillText(year, 40, 140);
            ctx.shadowBlur = 0;

            ctx.beginPath();
            ctx.moveTo(40, 160);
            ctx.lineTo(width - 40, 160);
            ctx.lineWidth = 2;
            ctx.strokeStyle = config.currentMode === MODES.LIGHT ? '#000' : '#00ffff';
            ctx.stroke();

            ctx.font = 'bold 40px Helvetica, Arial';
            ctx.fillStyle = config.textColor;
            ctx.fillText(title, 40, 220);

            ctx.font = 'normal 28px Helvetica, Arial';
            if (config.currentMode === MODES.NEON) ctx.fillStyle = '#ccc';

            const words = desc.split(' ');
            let line = '';
            let y = 280;
            for (let n = 0; n < words.length; n++) {
                const testLine = line + words[n] + ' ';
                const metrics = ctx.measureText(testLine);
                if (metrics.width > width - 80 && n > 0) {
                    ctx.fillText(line, 40, y);
                    line = words[n] + ' ';
                    y += 40;
                } else {
                    line = testLine;
                }
            }
            ctx.fillText(line, 40, y);

            ctx.fillStyle = config.currentMode === MODES.LIGHT ? '#000' : '#00ffff';
            ctx.fillRect(40, height - 40, 20, 20);
            ctx.fillRect(70, height - 40, 20, 20);

            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            return texture;
        }

        function onWindowResize() {
            const dpr = Math.min(window.devicePixelRatio, config.maxPixelRatio);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (bloomComposer) {
                bloomComposer.setPixelRatio(dpr);
                bloomComposer.setSize(window.innerWidth, window.innerHeight);
            }
            if (finalComposer) {
                finalComposer.setPixelRatio(dpr);
                finalComposer.setSize(window.innerWidth, window.innerHeight);
            }
        }
        function onDocumentMouseWheel(event) {
            event.preventDefault();
            targetCameraHeight += event.deltaY * 0.5;
            if (targetCameraHeight < 10) targetCameraHeight = 50;
            if (targetCameraHeight > 400) targetCameraHeight = 400;
        }
        function onMouseDown(event) { isDragging = true; previousMouseY = event.clientY; document.body.classList.add('grabbing'); }
        function onMouseUp() { isDragging = false; document.body.classList.remove('grabbing'); }
        function onMouseMove(event) {
            if (!isDragging) return;
            const deltaY = event.clientY - previousMouseY;
            previousMouseY = event.clientY;
            targetScrollPos += deltaY * 0.5;
        }

        function animate() {
            requestAnimationFrame(animate);
            globalUniforms.time.value += 0.02;

            scrollPos += (targetScrollPos - scrollPos) * 0.05;
            cameraHeight += (targetCameraHeight - cameraHeight) * 0.05;

            const currentIndex = Math.floor(scrollPos / config.spacingZ);
            const minIdx = currentIndex - config.renderRange;
            const maxIdx = currentIndex + config.renderRange;

            for (let i = minIdx; i <= maxIdx; i++) {
                if (!activeIndices.has(i)) { createRow(i); activeIndices.add(i); }
            }

            const targetX = Math.floor(config.laneCount / 2) * config.laneDist;
            const currentFocusZ = -scrollPos;
            camera.position.set(targetX - 100 * (cameraHeight / 100), cameraHeight, currentFocusZ + 120 * (cameraHeight / 100));
            camera.lookAt(targetX, 0, currentFocusZ);

            const light = scene.getObjectByName("mainLight");
            if (light) {
                light.position.set(targetX + 200, 1500, currentFocusZ + 200);
                light.target.position.set(targetX, 0, currentFocusZ);
                light.target.updateMatrixWorld();
            }

            for (let i = objects.length - 1; i >= 0; i--) {
                const obj = objects[i];
                const objIndex = obj.userData.index;
                if (objIndex < minIdx || objIndex > maxIdx) {
                    scene.remove(obj); disposeHierarchy(obj); objects.splice(i, 1); activeIndices.delete(objIndex);
                    continue;
                }
                const dist = obj.position.z - currentFocusZ;
                const isVisible = dist > (config.currentMode === MODES.LIGHT ? -750 : -650) && dist < (config.currentMode === MODES.LIGHT ? 500 : 300);

                let hiddenOffset = -50; if (obj.userData.type === 'top') hiddenOffset = 50;
                const targetY = isVisible ? obj.userData.baseY : (obj.userData.baseY + hiddenOffset);
                if (Math.abs(obj.position.y - targetY) > 0.01) obj.position.y = THREE.MathUtils.lerp(obj.position.y, targetY, 0.05);
                else obj.position.y = targetY;

                if (isVisible) {
                    obj.children.forEach(c => {
                        if (c.userData.type === 'flowingLight') {
                            c.userData.angle += c.userData.speed;
                            c.position.set(Math.cos(c.userData.angle) * c.userData.radius, 1 / 2, Math.sin(c.userData.angle) * c.userData.radius);
                        }
                        else if (c.userData.type === 'panelFlowingLight') {
                            c.userData.progress += c.userData.speed;
                            const p = c.userData.progress % 1;
                            let curY;
                            if (p < 0.5) curY = THREE.MathUtils.lerp(c.userData.startY, c.userData.endY, p * 2);
                            else curY = THREE.MathUtils.lerp(c.userData.endY, c.userData.startY, (p - 0.5) * 2);
                            c.position.set(c.userData.xPos, curY, c.userData.zPos);
                        }
                        else if (c.userData.type === 'crossFlowingLight') {
                            c.userData.progress += c.userData.speed;
                            const p = c.userData.progress % 1;
                            const pos = new THREE.Vector3().lerpVectors(new THREE.Vector3(0, 0, 0), c.userData.target, p);
                            c.position.copy(pos);
                        }
                        else if (c.userData.type === 'branchFlowingLight') {
                            c.userData.progress += c.userData.speed;
                            const p = c.userData.progress % 1;
                            const pos = new THREE.Vector3().lerpVectors(c.userData.startPos, c.userData.endPos, p);
                            c.position.copy(pos);
                        }
                    });
                }
            }

            if (config.currentMode === MODES.NEON && bloomComposer && finalComposer) {
                renderBloom();
                finalComposer.render();
            } else {
                renderer.render(scene, camera);
            }
        }

        function renderBloom() {
            const oldBg = scene.background;
            const oldFog = scene.fog;

            scene.background = new THREE.Color(0x000000);
            if (scene.fog) {
                scene.fog = scene.fog.clone();
                scene.fog.color.set(0x000000);
            }

            scene.traverse(darkenNonBloomed);
            bloomComposer.render();
            scene.traverse(restoreMaterial);

            scene.background = oldBg;
            scene.fog = oldFog;
        }

        function darkenNonBloomed(obj) {
            if (obj.isMesh || obj.isLine || obj.isLineSegments) {
                if (!obj.userData.bloom) {
                    obj.userData.originalMaterial = obj.material;
                    obj.material = mats.darkMaterial || (mats.darkMaterial = new THREE.MeshBasicMaterial({ color: "black" }));
                }
            }
        }

        function restoreMaterial(obj) {
            if (obj.userData.originalMaterial) {
                obj.material = obj.userData.originalMaterial;
                delete obj.userData.originalMaterial;
            }
        }

        init();
    </script>
</body>

</html>