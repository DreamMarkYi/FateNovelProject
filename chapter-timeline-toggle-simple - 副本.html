<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Timeline - Dual Color Volumetric Fog</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            cursor: grab;
            background-color: #020205;
            color: #fff;
        }

        body.grabbing {
            cursor: grabbing;
        }

        body.pointer {
            cursor: pointer !important;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            z-index: 10;
            transition: all 0.5s ease;
        }

        h1 {
            font-weight: 300;
            letter-spacing: 2px;
            margin: 0;
            text-transform: uppercase;
            font-size: 1.2rem;
            display: inline-block;
            padding-bottom: 5px;
            border-bottom: 1px solid #00ffff;
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        #ui {
            color: #fff;
            mix-blend-mode: difference;
        }

        p {
            font-size: 0.8rem;
            opacity: 0.8;
            margin-top: 5px;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            letter-spacing: 5px;
            transition: opacity 0.5s;
            pointer-events: none;
            color: #00ffff;
            text-shadow: 0 0 15px #00ffff;
        }
    </style>
</head>

<body>

    <div id="ui">
        <h1 id="ui-title">CHRONO INFINITY</h1>
        <p id="ui-desc">Initializing...</p>
    </div>

    <div id="loading" class="loading">SYSTEM INITIALIZING...</div>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/shaders/CopyShader.js"></script>
    <script
        src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script
        src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/postprocessing/ShaderPass.js"></script>
    <script
        src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <script>
        // --- GLSL 噪声函数库 ---
        const noiseCommon = `
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

        float snoise(vec3 v) {
            const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
            const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

            vec3 i  = floor(v + dot(v, C.yyy) );
            vec3 x0 = v - i + dot(i, C.xxx) ;

            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min( g.xyz, l.zxy );
            vec3 i2 = max( g.xyz, l.zxy );

            vec3 x1 = x0 - i1 + C.xxx;
            vec3 x2 = x0 - i2 + C.yyy;
            vec3 x3 = x0 - D.yyy;

            i = mod289(i);
            vec4 p = permute( permute( permute(
                        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                    + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                    + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

            float n_ = 0.142857142857;
            vec3  ns = n_ * D.wyz - D.xzx;

            vec4 j = p - 49.0 * floor(p * ns.z * ns.z);

            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_ );

            vec4 x = x_ *ns.x + ns.yyyy;
            vec4 y = y_ *ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);

            vec4 b0 = vec4( x.xy, y.xy );
            vec4 b1 = vec4( x.zw, y.zw );

            vec4 s0 = floor(b0)*2.0 + 1.0;
            vec4 s1 = floor(b1)*2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));

            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
            vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

            vec3 p0 = vec3(a0.xy,h.x);
            vec3 p1 = vec3(a0.zw,h.y);
            vec3 p2 = vec3(a1.xy,h.z);
            vec3 p3 = vec3(a1.zw,h.w);

            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
            p0 *= norm.x;
            p1 *= norm.y;
            p2 *= norm.z;
            p3 *= norm.w;

            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
            m = m * m;
            return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
                                        dot(p2,x2), dot(p3,x3) ) );
        }

        float fbm(vec3 x) {
            float v = 0.0;
            float a = 0.5;
            vec3 shift = vec3(100.0);
            for (int i = 0; i < 4; ++i) {
                v += a * snoise(x);
                x = x * 2.0 + shift;
                a *= 0.5;
            }
            return v;
        }
    `;

        // --- 配置参数 ---
        const config = {
            spacingZ: 2,
            renderRange: 20,
            laneCount: 5,
            laneDist: 60,
            maxPixelRatio: 1.5,

            bgColor: 0x6a868f,
            fogColor: 0x6a868f,
            cloudBaseColor: 0x6a868f,
            cloudHighlightColor: 0x6a868f,

            heightFogDensity: 0.008,
            heightFogBase: -200.0,

            mainBlockColor: 0xc4f0ff,
            bgBlockColor: 0x80d2ff,
            lineColor: 0x222222,

            mainEdgeColor: 0x00E0FF,
            dimEdgeColor: 0x005070,

            textColor: '#ffffff',
            uiTitle: "NEON CONFIG // COLOR CLOUD",
            uiDesc: "DUAL-COLOR VOLUMETRIC",
            seed: 12345
        };

        const globalUniforms = {
            time: { value: 0 },
            // [修改] 传入两个云层颜色
            cloudBaseColor: { value: new THREE.Color(config.cloudBaseColor) },
            cloudHighlightColor: { value: new THREE.Color(config.cloudHighlightColor) },
            fogColor: { value: new THREE.Color(config.fogColor) }
        };

        const STORY_EVENTS = [
            { tick: 0, year: "2024", title: "GENESIS", desc: "System Start.", lane: 2, color: "#ff0000" },
            { tick: 15, year: "2023", title: "ALPHA", desc: "Prototype.", lane: 1, color: "#00ff00" },
            { tick: 30, year: "2022", title: "BETA", desc: "Testing phase.", lane: 3 },
            { tick: 50, year: "2020", title: "CRISIS", desc: "Data Crash.", lane: 2, color: "#ffff00" },
            { tick: 70, year: "2015", title: "SEED", desc: "First idea.", lane: 0 },
            { tick: 90, year: "2000", title: "Y2K", desc: "Bug fix.", lane: 4 }
        ];

        const STORY_MAP = new Map();

        // [新增] 初始化节点链表关系
        function initNodeLinks() {
            STORY_EVENTS.forEach(evt => {
                evt.type = "story"; // 增加节点类型
                STORY_MAP.set(evt.tick, evt);
            });

            // 按 lane 分组并排序
            const lanes = {};
            STORY_EVENTS.forEach(evt => {
                if (!lanes[evt.lane]) lanes[evt.lane] = [];
                lanes[evt.lane].push(evt);
            });

            // 建立双向链表
            for (let l in lanes) {
                lanes[l].sort((a, b) => a.tick - b.tick);
                for (let i = 0; i < lanes[l].length; i++) {
                    if (i > 0) lanes[l][i].prev = lanes[l][i - 1];
                    if (i < lanes[l].length - 1) lanes[l][i].next = lanes[l][i + 1];
                }
            }
        }
        initNodeLinks();

        const CONNECTION_CONFIG = [
            { fromTick: 0, fromLane: 2, toTick: 15, toLane: 1, title: "DOWNGRADE", desc: "Ver 1.0 -> 0.9", color: "#ff00ff" },
            { fromTick: 15, fromLane: 1, toTick: 15, toLane: 3, title: "SYNC", desc: "Lateral Sync" },
            { fromTick: 30, fromLane: 3, toTick: 70, toLane: 0, title: "TIME LEAP", desc: "Deep Backup Restore", color: "#00ffff" },
            { fromTick: 50, fromLane: 2, toTick: 55, toLane: 4, title: "FORK", desc: "Emergency Branch" },
            { fromTick: 55, fromLane: 4, toTick: 70, toLane: 4, title: "ISOLATION", desc: "Safe Mode" }
        ];

        let scene, camera, renderer;
        let bloomComposer, finalComposer;
        let cloudMesh;

        let scrollPos = 320;
        let targetScrollPos = 320;

        let cameraOffsetX = 0;
        let targetCameraOffsetX = 0;

        let activeIndices = new Set();
        let cameraHeight = 100;
        let targetCameraHeight = 100;

        // [新增] 用于跟踪已生成的建筑区域，避免重复生成
        let generatedBuildingZones = new Set();
        const BUILDING_ZONE_SIZE = 200; // 每个区域的Z轴大小

        let isDragging = false;
        let previousMouseY = 0;
        let previousMouseX = 0;

        let objects = [];
        let mats = {};
        const BLOOM_LAYER = 1;

        let allParticles = [];
        const particleGeo = new THREE.SphereGeometry(0.2, 6, 6);
        let particleMat;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let interactiveObjects = [];
        let hoveredObject = null;

        function init() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(25, window.innerWidth / window.innerHeight, 10, 20000);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            const dpr = Math.min(window.devicePixelRatio, config.maxPixelRatio);
            renderer.setPixelRatio(dpr);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('wheel', onDocumentMouseWheel, { passive: false });

            document.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('mouseup', onMouseUp, false);
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('mouseleave', onMouseUp, false);

            document.addEventListener('click', onMouseClick, false);

            setupSceneMode();

            document.getElementById('loading').style.opacity = 0;
            animate();
        }

        function setupSceneMode() {
            scene.add(camera);
            clearScene();

            // 更新两个颜色的 Uniforms
            globalUniforms.cloudBaseColor.value.setHex(config.cloudBaseColor);
            globalUniforms.cloudHighlightColor.value.setHex(config.cloudHighlightColor);
            globalUniforms.fogColor.value.setHex(config.fogColor);

            document.getElementById('ui-title').innerText = config.uiTitle;
            document.getElementById('ui-desc').innerHTML = config.uiDesc + "<br>左上↔右下：前后移动 • 左下↔右上：左右移动<br>任意节点可点击";
            scene.background = new THREE.Color(config.bgColor);

            initMaterials();
            setupLights();
            createCloudFloor();
            setupPostProcessing();
            activeIndices.clear();
            interactiveObjects = [];
        }

        function clearScene() {
            for (let i = objects.length - 1; i >= 0; i--) {
                const obj = objects[i];
                scene.remove(obj);
                disposeHierarchy(obj);
            }
            if (cloudMesh) {
                scene.remove(cloudMesh);
                if (cloudMesh.geometry) cloudMesh.geometry.dispose();
                if (cloudMesh.material) cloudMesh.material.dispose();
                cloudMesh = null;
            }
            objects = [];
            allParticles = [];
            generatedBuildingZones.clear(); // [新增] 清理建筑区域标记
            const oldLights = scene.children.filter(c => c.isLight || c.type === 'GridHelper');
            oldLights.forEach(l => { scene.remove(l); if (l.dispose) l.dispose(); });
        }

        function disposeHierarchy(node) {
            node.traverse((child) => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) child.material.forEach(m => { if (m.map) m.map.dispose(); m.dispose(); });
                    else { if (child.material.map) child.material.map.dispose(); child.material.dispose(); }
                }
            });
        }

        function createCloudFloor() {
            const geometry = new THREE.PlaneGeometry(8000, 8000, 100, 100);

            // [修改] Shader 现在接收 uBaseColor 和 uHighlightColor
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: globalUniforms.time,
                    uBaseColor: globalUniforms.cloudBaseColor,
                    uHighlightColor: globalUniforms.cloudHighlightColor,
                    uFogColor: globalUniforms.fogColor,
                    uCameraPos: { value: camera.position }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying vec3 vWorldPosition;
                    void main() {
                        vUv = uv;
                        vec4 worldPos = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPos.xyz;
                        gl_Position = projectionMatrix * viewMatrix * worldPos;
                    }
                `,
                fragmentShader: `
                    uniform float uTime;
                    uniform vec3 uBaseColor;
                    uniform vec3 uHighlightColor;
                    uniform vec3 uFogColor;
                    varying vec2 vUv;
                    varying vec3 vWorldPosition;

                    ${noiseCommon}

                    void main() {
                        vec3 pos = vWorldPosition * 0.002;
                        pos.x += uTime * 0.05;
                        pos.z += uTime * 0.02;

                        float noise = fbm(pos + vec3(0.0, uTime * 0.1, 0.0));

                        float alpha = smoothstep(-0.2, 0.8, noise);

                        float dist = length(vWorldPosition.xz - cameraPosition.xz);
                        float fade = 1.0 - smoothstep(1000.0, 3500.0, dist);

                        // [关键修改] 双色混合逻辑
                        // 根据噪声强度在底色和高光色之间插值
                        // noise 值通常在 -1 到 1 之间，我们将其归一化并调整对比度
                        float toneMix = smoothstep(0.3, 0.8, noise * 0.5 + 0.5);
                        vec3 cloudMix = mix(uBaseColor, uHighlightColor, toneMix);

                        // 再与雾色混合
                        vec3 finalColor = mix(uFogColor, cloudMix, noise * 0.5 + 0.5);

                        // 增加高光处的亮度，产生"自发光"感
                        finalColor += uHighlightColor * smoothstep(0.65, 1.0, noise) * 0.5;

                        gl_FragColor = vec4(finalColor, alpha * fade * 0.9);
                    }
                `,
                transparent: true,
                depthWrite: false,
                side: THREE.DoubleSide
            });

            cloudMesh = new THREE.Mesh(geometry, material);
            cloudMesh.rotation.x = -Math.PI / 2;
            cloudMesh.position.y = config.heightFogBase - 50;
            scene.add(cloudMesh);
        }

        function getVolumetricFogShaderLogic() {
            return (shader) => {
                shader.uniforms.uTime = globalUniforms.time;
                shader.uniforms.hFogColor = globalUniforms.fogColor;
                shader.uniforms.hFogDensity = { value: config.heightFogDensity };
                shader.uniforms.hFogBase = { value: config.heightFogBase };

                shader.vertexShader = `
                    varying vec3 vWorldPosition;
                    ${shader.vertexShader}
                `.replace(
                    `#include <begin_vertex>`,
                    `#include <begin_vertex>
                     vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;`
                );

                shader.fragmentShader = `
                    uniform float uTime;
                    uniform vec3 hFogColor;
                    uniform float hFogDensity;
                    uniform float hFogBase;
                    varying vec3 vWorldPosition;

                    ${noiseCommon}

                    ${shader.fragmentShader}
                `.replace(
                    `#include <fog_fragment>`,
                    `
                    vec3 noisePos = vWorldPosition * 0.005;
                    noisePos.y *= 0.5;
                    noisePos.x += uTime * 0.05;

                    float noise = fbm(noisePos);

                    float distY = vWorldPosition.y - hFogBase;
                    float heightFactor = 0.0;

                    if (distY > 0.0) {
                        heightFactor = exp(-distY * hFogDensity * (1.0 + noise));
                    } else {
                        heightFactor = 1.0;
                    }

                    float dist = length(vWorldPosition - cameraPosition);
                    float distFactor = 1.0 - exp(-dist * 0.0002);

                    float totalFog = clamp(heightFactor + distFactor, 0.0, 1.0);

                    gl_FragColor.rgb = mix(gl_FragColor.rgb, hFogColor, totalFog);

                    #include <fog_fragment>
                    `
                );
            };
        }

        function initMaterials() {
            const shaderLogic = getVolumetricFogShaderLogic();
            mats = {};

            particleMat = new THREE.MeshBasicMaterial({
                color: config.mainEdgeColor,
                transparent: true,
                opacity: 1.0,
                blending: THREE.AdditiveBlending
            });

            const mainBoxColor = new THREE.Color(config.mainBlockColor);
            mainBoxColor.multiplyScalar(1.0);
            mats.mainBox = new THREE.MeshLambertMaterial({ color: mainBoxColor });
            mats.mainBox.onBeforeCompile = shaderLogic;

            const bgBoxColor = new THREE.Color(config.bgBlockColor);
            bgBoxColor.multiplyScalar(1.0);
            mats.bgBox = new THREE.MeshLambertMaterial({ color: bgBoxColor });
            mats.bgBox.onBeforeCompile = shaderLogic;

            const lineColor = new THREE.Color(config.mainEdgeColor);
            lineColor.multiplyScalar(1.0);
            mats.line = new THREE.LineBasicMaterial({
                color: lineColor,
                transparent: true,
                opacity: 0.95
            });
            mats.line.onBeforeCompile = shaderLogic;

            const glowEdgeColor = new THREE.Color(config.mainEdgeColor);
            glowEdgeColor.multiplyScalar(1.0);
            mats.glowEdges = new THREE.LineBasicMaterial({
                color: glowEdgeColor,
                linewidth: 2,
                transparent: true,
                opacity: 1.0
            });
            mats.glowEdges.onBeforeCompile = shaderLogic;

            const dimEdgeColor = new THREE.Color(config.dimEdgeColor);
            dimEdgeColor.multiplyScalar(1.0);
            mats.dimEdges = new THREE.LineBasicMaterial({
                color: dimEdgeColor,
                transparent: true,
                opacity: 0.85,
                linewidth: 2
            });
            mats.dimEdges.onBeforeCompile = shaderLogic;
            mats.bgEdges = mats.dimEdges;

            mats.mainEdges = mats.glowEdges;

            mats.person = new THREE.MeshBasicMaterial({ color: 0x00aaaa });
            mats.person.onBeforeCompile = shaderLogic;
        }

        function setupLights() {
            scene.add(new THREE.AmbientLight(0x222222, 0.5));

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight.name = "mainLight";
            dirLight.position.set(100, 200, 100);
            dirLight.color.setHSL(0.6, 0.2, 0.5);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;
            const shadowRange = config.laneCount * config.laneDist + 4000;
            dirLight.shadow.camera.left = -2000;
            dirLight.shadow.camera.right = shadowRange;
            dirLight.shadow.camera.top = 2000;
            dirLight.shadow.camera.bottom = -2000;
            scene.add(dirLight);
        }

        function setupPostProcessing() {
            const dpr = Math.min(window.devicePixelRatio, config.maxPixelRatio);
            const width = window.innerWidth;
            const height = window.innerHeight;
            const renderScene = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(width * dpr, height * dpr), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0;
            bloomPass.strength = 1.5;
            bloomPass.radius = 0.5;

            bloomComposer = new THREE.EffectComposer(renderer);
            bloomComposer.renderToScreen = false;
            bloomComposer.addPass(renderScene);
            bloomComposer.addPass(bloomPass);

            const finalPass = new THREE.ShaderPass(
                new THREE.ShaderMaterial({
                    uniforms: {
                        baseTexture: { value: null },
                        bloomTexture: { value: bloomComposer.renderTarget2.texture }
                    },
                    vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); }`,
                    fragmentShader: `uniform sampler2D baseTexture; uniform sampler2D bloomTexture; varying vec2 vUv; void main()
                    {
                    vec4 base = texture2D( baseTexture, vUv );
                    vec4 bloom = texture2D( bloomTexture, vUv );
                    gl_FragColor = base + bloom;
                    }`,
                }), "baseTexture"
            );
            finalPass.needsSwap = true;
            finalComposer = new THREE.EffectComposer(renderer);
            finalComposer.addPass(renderScene);
            finalComposer.addPass(finalPass);
            bloomComposer.setSize(width, height);
            bloomComposer.setPixelRatio(dpr);
            finalComposer.setSize(width, height);
            finalComposer.setPixelRatio(dpr);
        }

        function enableBloom(obj) { obj.layers.set(BLOOM_LAYER); }

        function spawnFlowingParticles(startPointLocal, endVectorLocal, parentGroup, count = 4) {
            const len = endVectorLocal.length();
            const density = Math.max(count, Math.floor(len / 40));

            const dirNorm = endVectorLocal.clone().normalize();
            let sideVec = new THREE.Vector3().crossVectors(dirNorm, new THREE.Vector3(0, 1, 0)).normalize();
            if (sideVec.lengthSq() < 0.01) sideVec = new THREE.Vector3(1, 0, 0);

            for (let i = 0; i < density; i++) {
                const pMesh = new THREE.Mesh(particleGeo, particleMat);
                enableBloom(pMesh);
                pMesh.userData.isParticle = true;
                pMesh.userData.type = 'flow';
                pMesh.userData.flowData = {
                    start: startPointLocal.clone(), endVec: endVectorLocal, sideVec: sideVec,
                    sideModifier: i % 2 === 0 ? 1 : -1, progress: Math.random(),
                    speed: 0.002 + Math.random() * 0.005, phase: Math.random() * Math.PI * 2,
                    wobbleSpeed: 2.0 + Math.random() * 3.0, wobbleAmp: 0.5 + Math.random() * 0.5
                };
                pMesh.position.copy(pMesh.userData.flowData.start);
                parentGroup.add(pMesh);
                allParticles.push(pMesh);
            }
        }

        function spawnRisingParticles(parentGroup, count = 20) {
            const totalWidth = config.laneCount * config.laneDist;
            for (let i = 0; i < count; i++) {
                const pMesh = new THREE.Mesh(particleGeo, particleMat);
                enableBloom(pMesh);
                const rX = (Math.random() - 0.5) * totalWidth * 20;
                const startY = -200 - Math.random() * 400;
                pMesh.position.set(rX, startY, (Math.random() - 0.5) * 100);
                pMesh.userData.isParticle = true;
                pMesh.userData.type = 'rise';
                pMesh.userData.riseData = {
                    minY: startY, maxY: 50 + Math.random() * 100, speed: 0.2 + Math.random() * 0.4,
                    driftSpeed: 0.01 + Math.random() * 0.02, driftPhase: Math.random() * Math.PI * 2
                };
                parentGroup.add(pMesh);
                allParticles.push(pMesh);
            }
        }

        function createRow(index) {
            const laneGroups = [];
            for (let l = 0; l < config.laneCount; l++) laneGroups.push(createLane(index, l));

            //if (laneGroups.length > 2) spawnRisingParticles(laneGroups[2], 200);

            const outboundConnections = CONNECTION_CONFIG.filter(c => c.fromTick === index);

            outboundConnections.forEach(conn => {
                if (conn.fromLane < config.laneCount && conn.toLane < config.laneCount && laneGroups[conn.fromLane]) {
                    const groupA = laneGroups[conn.fromLane];

                    // [修改] 使用 getPosition 获取实际节点位置，解决连线偏差
                    const startPos = getPosition(conn.fromTick, conn.fromLane);
                    const endPos = getPosition(conn.toTick, conn.toLane);
                    const vecAB = endPos.clone().sub(startPos);

                    const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), vecAB]);
                    const linkLine = new THREE.Line(lineGeo, mats.glowEdges);
                    enableBloom(linkLine);
                    groupA.add(linkLine);
                    spawnFlowingParticles(new THREE.Vector3(0, 0, 0), vecAB, groupA);

                    const midPoint = vecAB.clone().multiplyScalar(0.5);
                    const bridgeNode = new THREE.Group();
                    bridgeNode.position.copy(midPoint);

                    const boxGeo = new THREE.BoxGeometry(1, 1, 1);
                    const scaleX = 12, scaleY = 2, scaleZ = 6;
                    const mesh = new THREE.Mesh(boxGeo, mats.mainBox);
                    mesh.scale.set(scaleX, scaleY, scaleZ);
                    bridgeNode.add(mesh);

                    const edgeGeo = new THREE.EdgesGeometry(boxGeo);
                    const edges = new THREE.LineSegments(edgeGeo, mats.mainEdges);
                    edges.scale.set(scaleX, scaleY, scaleZ);
                    enableBloom(edges);
                    bridgeNode.add(edges);

                    if (conn.title) {
                        const textTex = createTextTexture("", conn.title, conn.desc || "LINK");
                        const pMat = new THREE.MeshBasicMaterial({
                            map: textTex,
                            side: THREE.DoubleSide,
                            transparent: true,
                            depthWrite: false,
                            blending: THREE.AdditiveBlending
                        });
                        pMat.onBeforeCompile = getVolumetricFogShaderLogic();
                        const panel = new THREE.Mesh(new THREE.PlaneGeometry(6, 6), pMat);
                        panel.position.set(0, 4, 0);
                        panel.rotation.y = -Math.PI / 4;
                        bridgeNode.add(panel);

                        const stick = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 4, 0)]), mats.line);
                        enableBloom(stick);
                        bridgeNode.add(stick);
                    }
                    groupA.add(bridgeNode);
                }
            });
        }

        function getPosition(index, laneIdx) {
            const seed = Math.sin(index * 12.9898 + (laneIdx * 999.99)) * 43758.5453;
            const pseudoRand = (offset) => (Math.sin(seed + offset) * 10000) % 1;
            const laneOffsetX = laneIdx * config.laneDist;
            const xPos = laneOffsetX + pseudoRand(1) * 20;
            const yPos = pseudoRand(2) * 5;
            const zPos = -index * config.spacingZ;
            return new THREE.Vector3(xPos, yPos, zPos);
        }

        function createLane(index, laneIdx) {
            const boxGeo = new THREE.BoxGeometry(1, 1, 1);
            const personGeo = new THREE.ConeGeometry(0.15, 0.8, 8);
            const data = generateDataForIndex(index, laneIdx);

            const seed = Math.sin(index * 12.9898 + (laneIdx * 999.99)) * 43758.5453;
            const pseudoRand = (offset) => (Math.sin(seed + offset) * 10000) % 1;

            // [修改] 新增基于 config.seed 的随机生成器
            const seedVal = config.seed || 12345;
            const seed2 = Math.sin(index * 12.9898 + (laneIdx * 999.99) + seedVal) * 43758.5453;
            const seedRand = (offset) => (Math.sin(seed2 + offset) * 10000) % 1;

            const zPos = -index * config.spacingZ;
            const laneOffsetX = laneIdx * config.laneDist;
            const group = new THREE.Group();

            const xPos = laneOffsetX + pseudoRand(1) * 20;
            const yPos = pseudoRand(2) * 5;
            group.position.set(xPos, yPos, zPos);
            group.userData = { baseY: yPos, type: 'main', index: index, lane: laneIdx };

            // [修改] 主线生成逻辑：只在有节点的地方生成，并连接到下一个节点
            if (data.isStory) {
                const evt = STORY_MAP.get(index);

                // 1. 生成连接线 (如果有下一个节点)
                if (evt && evt.next) {
                    const nextPosGlobal = getPosition(evt.next.tick, evt.next.lane);
                    // 转换为当前 group 的局部坐标
                    const lineEndLocal = nextPosGlobal.clone().sub(group.position);

                    const mainLine = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), lineEndLocal]), mats.line);
                    enableBloom(mainLine);
                    group.add(mainLine);
                }

                // 2. 生成节点平台
                const scaleMult = 5; // 故事节点固定放大
                const mainSx = (3 + Math.abs(pseudoRand(3)) * 2) * scaleMult;
                const mainSy = (1 + Math.abs(pseudoRand(4)) * 1) * scaleMult * 0.5;
                const mainSz = (3 + Math.abs(pseudoRand(5)) * 2) * scaleMult;

                const platform = new THREE.Mesh(boxGeo, mats.mainBox);
                platform.scale.set(mainSx, mainSy, mainSz);
                platform.castShadow = true; platform.receiveShadow = true;

                platform.userData = {
                    isInteractive: true,
                    originScale: new THREE.Vector3(mainSx, mainSy, mainSz),
                    storyData: data
                };
                interactiveObjects.push(platform);

                const platformEdges = new THREE.LineSegments(new THREE.EdgesGeometry(boxGeo), mats.mainEdges);
                enableBloom(platformEdges);
                platform.add(platformEdges);
                group.add(platform);

                const lineHeight = 10 + Math.abs(pseudoRand(6)) * 5;
                const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, lineHeight, 0)]), mats.glowEdges);
                line.position.set(mainSx / 2 - 0.5, mainSy / 2, mainSz / 2 - 0.5);
                enableBloom(line);
                group.add(line);

                const panelMat = new THREE.MeshBasicMaterial({
                    map: createTextTexture(data.year, data.title, data.desc),
                    side: THREE.DoubleSide,
                    transparent: true,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending
                });
                panelMat.onBeforeCompile = getVolumetricFogShaderLogic();
                const panel = new THREE.Mesh(new THREE.PlaneGeometry(8, 8), panelMat);
                panel.position.set(mainSx / 2 - 0.5 + 4, mainSy / 2 + lineHeight, mainSz / 2 - 0.5);
                panel.rotation.y = -Math.PI / 4;
                group.add(panel);
                enableBloom(panel); // Added enableBloom for panel
                const person = new THREE.Mesh(personGeo, mats.person);
                person.position.set(0, mainSy / 2 + 0.4, 0);
                group.add(person);
            }

            scene.add(group); objects.push(group);

            // [移除] 建筑生成已改为完全随机，不再依赖主线节点
            // createDecorBuildings(index, laneIdx, zPos, laneOffsetX, pseudoRand, seedRand, boxGeo);

            return group;
        }

        // [修改] 完全随机生成建筑，不依赖主线节点
        function createRandomBuildings(centerZ) {
            const boxGeo = new THREE.BoxGeometry(1, 1, 1);
            const totalWidth = config.laneCount * config.laneDist;

            // 使用完全随机的种子生成器
            const randomSeed = () => Math.random();

            // 底部建筑：随机生成 3-8 个
            const bottomCount = 3 + Math.floor(randomSeed() * 6);
            for (let k = 0; k < bottomCount; k++) {
                const bGroup = new THREE.Group();

                // 完全随机的位置
                const bZPos = centerZ + (randomSeed() - 0.5) * BUILDING_ZONE_SIZE * 2;
                const bXPos = (randomSeed() - 0.5) * totalWidth * 3; // 超出车道范围
                const bYBase = -240 - randomSeed() * 200;

                // 底部建筑初始位置设为隐藏位置（更低处），这样滚动时才能从下方滑入
                const hiddenOffset = -50;
                bGroup.position.set(bXPos, bYBase + hiddenOffset, bZPos);

                bGroup.userData = {
                    baseY: bYBase,
                    type: 'bottom',
                    index: -1, // 不再依赖 index
                    animSpeed: 0.075 + randomSeed() * 0.26,
                    animPhase: randomSeed() * Math.PI * 2,
                    animAmp: 2 + randomSeed() * 4
                };

                // 完全随机的尺寸
                const h = 30 + randomSeed() * 300;
                const w = 10 + randomSeed() * 20;

                const bMesh = new THREE.Mesh(boxGeo, mats.bgBox);
                bMesh.scale.set(w, h, w); bMesh.position.set(0, h / 2, 0);
                bGroup.add(bMesh);

                const bLines = new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.BoxGeometry(w, h, w)), mats.bgEdges);
                bLines.position.set(0, h / 2, 0);
                bGroup.add(bLines);
                scene.add(bGroup); objects.push(bGroup);
            }

            // 顶部建筑：随机生成 2-5 个
            const topCount = 2 + Math.floor(randomSeed() * 4);
            for (let k = 0; k < topCount; k++) {
                const tGroup = new THREE.Group();

                // 完全随机的位置
                const tZPos = centerZ + (randomSeed() - 0.5) * BUILDING_ZONE_SIZE * 2;
                let tXPos = (randomSeed() - 0.5) * totalWidth * 3;
                if (Math.abs(tXPos) < 30) tXPos += (tXPos > 0 ? 30 : -30);
                const tYBase = 600 + randomSeed() * 300;

                // 顶部建筑初始位置设为隐藏位置（更高处），这样滚动时才能从上方滑入
                const hiddenOffset = 50;
                tGroup.position.set(tXPos, tYBase + hiddenOffset, tZPos);

                tGroup.userData = {
                    baseY: tYBase,
                    type: 'top',
                    index: -1, // 不再依赖 index
                    animSpeed: 0.1 + randomSeed() * 1.5,
                    animPhase: randomSeed() * Math.PI * 2,
                    animAmp: 5 + randomSeed() * 15
                };

                // 完全随机的楼层数和尺寸
                const floors = 2 + Math.floor(randomSeed() * 4);
                let cY = 0;
                const baseW = 15 + randomSeed() * 25, baseD = 15 + randomSeed() * 25;
                for (let f = 0; f < floors; f++) {
                    const h = 50 + randomSeed() * 40;
                    const taper = 1.0 - (f * 0.05);
                    const w = baseW * taper, d = baseD * taper;

                    const tMesh = new THREE.Mesh(boxGeo, mats.bgBox);
                    tMesh.scale.set(w, h, d); tMesh.position.set(0, cY - h / 2, 0);
                    tMesh.castShadow = true; tMesh.receiveShadow = true;
                    tGroup.add(tMesh);

                    const tLines = new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.BoxGeometry(w, h, d)), mats.bgEdges);
                    tLines.position.set(0, cY - h / 2, 0);
                    tGroup.add(tLines);
                    cY -= h;
                }
                scene.add(tGroup); objects.push(tGroup);
            }
        }

        function interpolateYear(tick) {
            let prev = STORY_EVENTS[0];
            let next = STORY_EVENTS[STORY_EVENTS.length - 1];

            for (let i = 0; i < STORY_EVENTS.length; i++) {
                if (STORY_EVENTS[i].tick <= tick) prev = STORY_EVENTS[i];
                if (STORY_EVENTS[i].tick >= tick) {
                    next = STORY_EVENTS[i];
                    break;
                }
            }

            if (prev === next) return prev.year;

            const range = next.tick - prev.tick;
            const dist = tick - prev.tick;
            const ratio = dist / range;

            const y1 = parseInt(prev.year);
            const y2 = parseInt(next.year);
            if (!isNaN(y1) && !isNaN(y2)) {
                return (y1 + (y2 - y1) * ratio).toFixed(1);
            }
            return "";
        }

        function generateDataForIndex(i, laneIdx) {
            if (STORY_MAP.has(i)) {
                const evt = STORY_MAP.get(i);
                if (evt.lane === laneIdx) {
                    return { year: evt.year, title: evt.title, desc: evt.desc, isStory: true };
                }
            }
            const seed = Math.sin(i * 9999 + laneIdx * 777) * 43758.5453;
            const hasText = (Math.abs(seed) % 1) > 0.3;
            const yearStr = interpolateYear(i);

            return {
                year: hasText ? yearStr : "",
                title: hasText ? `N-${i}` : "",
                desc: hasText ? "..." : "",
                isStory: false
            };
        }

        function createTextTexture(year, title, desc) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const width = 512, height = 512;
            canvas.width = width;
            canvas.height = height;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
            ctx.fillRect(0, 0, width, height);
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 6;
            ctx.strokeRect(0, 0, width, height);
            ctx.fillStyle = config.textColor;
            ctx.shadowColor = "#00ffff";
            ctx.shadowBlur = 10;

            ctx.textAlign = 'left';
            ctx.font = 'bold 100px Helvetica, Arial';
            ctx.fillText(year, 40, 130);
            ctx.shadowBlur = 0;

            ctx.beginPath();
            ctx.moveTo(40, 150);
            ctx.lineTo(width - 40, 150);
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#00ffff';
            ctx.stroke();

            ctx.font = 'bold 40px Helvetica, Arial';
            ctx.fillStyle = config.textColor;
            ctx.fillText(title, 40, 210);

            ctx.font = 'normal 28px Helvetica, Arial';
            ctx.fillStyle = '#ccc';

            const words = desc.split(' ');
            let line = '', y = 270;
            for (let n = 0; n < words.length; n++) {
                if (ctx.measureText(line + words[n]).width > width - 80) {
                    ctx.fillText(line, 40, y);
                    line = words[n] + ' ';
                    y += 40;
                }
                else line += words[n] + ' ';
            }
            ctx.fillText(line, 40, y);
            return new THREE.CanvasTexture(canvas);
        }

        function onWindowResize() {
            const dpr = Math.min(window.devicePixelRatio, config.maxPixelRatio);
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (bloomComposer) { bloomComposer.setSize(window.innerWidth, window.innerHeight); bloomComposer.setPixelRatio(dpr); }
            if (finalComposer) { finalComposer.setSize(window.innerWidth, window.innerHeight); finalComposer.setPixelRatio(dpr); }
        }

        function onDocumentMouseWheel(event) { event.preventDefault(); targetCameraHeight = Math.max(50, Math.min(400, targetCameraHeight + event.deltaY * 0.5)); }

        function onMouseDown(event) {
            isDragging = true;
            previousMouseY = event.clientY;
            previousMouseX = event.clientX;
            document.body.classList.add('grabbing');
        }

        function onMouseUp() {
            isDragging = false;
            document.body.classList.remove('grabbing');
        }

        function onMouseClick(event) {
            if (isDragging) return;

            if (hoveredObject) {
                const info = hoveredObject.userData.storyData;
                const displayTitle = info.title ? info.title : "普通节点";
                const displayYear = info.year ? `[${info.year}]` : "";
                const displayDesc = info.desc ? info.desc : "无详细描述数据...";

                alert(`选中: ${displayYear} ${displayTitle}\n\n${displayDesc}`);
            }
        }

        function checkIntersection() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(interactiveObjects);

            if (intersects.length > 0) {
                const object = intersects[0].object;
                if (hoveredObject !== object) {
                    if (hoveredObject) restoreObject(hoveredObject);
                    hoveredObject = object;
                    highlightObject(hoveredObject);
                }
            } else {
                if (hoveredObject) {
                    restoreObject(hoveredObject);
                    hoveredObject = null;
                }
            }
        }

        function highlightObject(mesh) {
            document.body.classList.add('pointer');
            const targetScale = mesh.userData.originScale.clone().multiplyScalar(1.2);
            mesh.scale.copy(targetScale);
        }

        function restoreObject(mesh) {
            document.body.classList.remove('pointer');
            mesh.scale.copy(mesh.userData.originScale);
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            if (!isDragging) {
                checkIntersection();
                return;
            }

            const deltaX = event.clientX - previousMouseX;
            const deltaY = event.clientY - previousMouseY;

            const scrollInput = (deltaX + deltaY);
            targetScrollPos += scrollInput * 0.35;

            const panInput = (deltaX - deltaY);
            targetCameraOffsetX -= panInput * 0.35;

            previousMouseX = event.clientX;
            previousMouseY = event.clientY;
        }

        function updateParticles() {
            const t = globalUniforms.time.value;
            allParticles.forEach(pMesh => {
                if (pMesh.userData.type === 'flow') {
                    const data = pMesh.userData.flowData;
                    data.progress = (data.progress + data.speed) % 1;
                    const wobble = Math.sin(t * data.wobbleSpeed + data.phase) * data.wobbleAmp;
                    pMesh.position.copy(data.start).add(data.endVec.clone().multiplyScalar(data.progress)).add(data.sideVec.clone().multiplyScalar((1.2 + wobble) * data.sideModifier));
                } else if (pMesh.userData.type === 'rise') {
                    const data = pMesh.userData.riseData;
                    pMesh.position.y += data.speed;
                    if (pMesh.position.y > data.maxY) pMesh.position.y = data.minY;
                    pMesh.position.x += Math.sin(t * data.driftSpeed + data.driftPhase) * 0.1;
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            globalUniforms.time.value += 0.02;
            updateParticles();

            if (cloudMesh) {
                cloudMesh.position.x = camera.position.x;
                cloudMesh.position.z = camera.position.z;
            }

            scrollPos += (targetScrollPos - scrollPos) * 0.05;
            cameraOffsetX += (targetCameraOffsetX - cameraOffsetX) * 0.05;

            cameraHeight += (targetCameraHeight - cameraHeight) * 0.05;
            const currentIndex = Math.floor(scrollPos / config.spacingZ);
            const minIdx = currentIndex - config.renderRange, maxIdx = currentIndex + config.renderRange;

            for (let i = minIdx; i <= maxIdx; i++) {
                if (!activeIndices.has(i)) { createRow(i); activeIndices.add(i); }
            }

            // [新增] 随机生成建筑，不依赖主线节点
            const currentFocusZ = -scrollPos;
            const buildingRenderRange = 2000; // 建筑生成范围
            const minBuildingZ = currentFocusZ - buildingRenderRange;
            const maxBuildingZ = currentFocusZ + buildingRenderRange;

            // 计算需要生成的建筑区域
            const minZone = Math.floor(minBuildingZ / BUILDING_ZONE_SIZE);
            const maxZone = Math.floor(maxBuildingZ / BUILDING_ZONE_SIZE);

            // 为每个未生成的区域生成建筑
            for (let zone = minZone; zone <= maxZone; zone++) {
                if (!generatedBuildingZones.has(zone)) {
                    const zoneCenterZ = zone * BUILDING_ZONE_SIZE;
                    createRandomBuildings(zoneCenterZ);
                    generatedBuildingZones.add(zone);
                }
            }

            const baseCenterX = Math.floor(config.laneCount / 2) * config.laneDist;
            // currentFocusZ 已在上面声明，这里直接使用

            const finalCamX = baseCenterX + cameraOffsetX - 100 * (cameraHeight / 100);

            camera.position.set(finalCamX, cameraHeight, currentFocusZ + 120 * (cameraHeight / 100));
            camera.lookAt(baseCenterX + cameraOffsetX, 0, currentFocusZ);

            const light = scene.getObjectByName("mainLight");
            if (light) {
                light.position.set(baseCenterX + cameraOffsetX + 200, 1500, currentFocusZ + 200);
                light.target.position.set(baseCenterX + cameraOffsetX, 0, currentFocusZ);
                light.target.updateMatrixWorld();
            }

            for (let i = objects.length - 1; i >= 0; i--) {
                const obj = objects[i];
                // [修改] 对于主线节点（index >= 0），按原来的逻辑清理
                // 对于随机建筑（index === -1），根据Z轴距离清理
                const shouldRemove = (obj.userData.index >= 0 && (obj.userData.index < minIdx || obj.userData.index > maxIdx)) ||
                                     (obj.userData.index === -1 && (obj.position.z < minBuildingZ || obj.position.z > maxBuildingZ));

                if (shouldRemove) {
                    obj.traverse((child) => {
                        if (child.userData && child.userData.isInteractive) {
                            const idx = interactiveObjects.indexOf(child);
                            if (idx > -1) interactiveObjects.splice(idx, 1);
                            if (hoveredObject === child) {
                                hoveredObject = null;
                                document.body.classList.remove('pointer');
                            }
                        }
                    });

                    scene.remove(obj); disposeHierarchy(obj); objects.splice(i, 1);
                    if (obj.userData.index >= 0) {
                        activeIndices.delete(obj.userData.index);
                    } else {
                        // 清理建筑区域标记，允许重新生成
                        const zone = Math.floor(obj.position.z / BUILDING_ZONE_SIZE);
                        generatedBuildingZones.delete(zone);
                    }
                } else {
                    let hiddenOffset = -50;
                    if (obj.userData.type === 'top') hiddenOffset = 50;

                    const isVisible = (obj.position.z - currentFocusZ) > -1200 && (obj.position.z - currentFocusZ) < 800;

                    let floatOffset = 0;
                    if ((obj.userData.type === 'top' || obj.userData.type === 'bottom') && obj.userData.animSpeed) {
                        const t = globalUniforms.time.value;
                        floatOffset = Math.sin(t * obj.userData.animSpeed + obj.userData.animPhase) * obj.userData.animAmp;
                    }

                    const targetY = isVisible ? (obj.userData.baseY + floatOffset) : (obj.userData.baseY + hiddenOffset);
                    obj.position.y = THREE.MathUtils.lerp(obj.position.y, targetY, 0.05);
                }
            }

            if (bloomComposer) {
                if (cloudMesh) cloudMesh.visible = false;
                scene.background = new THREE.Color(0x000000);
                camera.layers.set(BLOOM_LAYER);
                bloomComposer.render();

                if (cloudMesh) cloudMesh.visible = true;
                scene.background = new THREE.Color(config.bgColor);
                camera.layers.set(0);
                finalComposer.render();
            }
        }

        init();
    </script>
</body>

</html>